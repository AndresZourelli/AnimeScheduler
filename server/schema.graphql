"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `AgeRating`."""
  ageRatings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AgeRating`."""
    orderBy: [AgeRatingsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgeRatingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AgeRatingFilter
  ): AgeRatingsConnection

  """Reads and enables pagination through a set of `AiringStatus`."""
  airingStatuses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AiringStatus`."""
    orderBy: [AiringStatusesOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AiringStatusCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AiringStatusFilter
  ): AiringStatusesConnection

  """Reads and enables pagination through a set of `AlternateAnimeName`."""
  alternateAnimeNames(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AlternateAnimeName`."""
    orderBy: [AlternateAnimeNamesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AlternateAnimeNameCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AlternateAnimeNameFilter
  ): AlternateAnimeNamesConnection

  """Reads and enables pagination through a set of `AnimeCharacter`."""
  animeCharacters(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeCharacter`."""
    orderBy: [AnimeCharactersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeCharacterCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeCharacterFilter
  ): AnimeCharactersConnection

  """Reads and enables pagination through a set of `AnimeGenre`."""
  animeGenres(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeGenre`."""
    orderBy: [AnimeGenresOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeGenreCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeGenreFilter
  ): AnimeGenresConnection

  """Reads and enables pagination through a set of `AnimeImage`."""
  animeImages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeImage`."""
    orderBy: [AnimeImagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeImageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeImageFilter
  ): AnimeImagesConnection

  """Reads and enables pagination through a set of `AnimeLicensor`."""
  animeLicensors(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeLicensor`."""
    orderBy: [AnimeLicensorsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeLicensorCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeLicensorFilter
  ): AnimeLicensorsConnection

  """Reads and enables pagination through a set of `AnimeList`."""
  animeLists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeList`."""
    orderBy: [AnimeListsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeListCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeListFilter
  ): AnimeListsConnection

  """Reads and enables pagination through a set of `AnimeProducer`."""
  animeProducers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeProducer`."""
    orderBy: [AnimeProducersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeProducerCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeProducerFilter
  ): AnimeProducersConnection

  """Reads and enables pagination through a set of `AnimeStaff`."""
  animeStaffs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeStaff`."""
    orderBy: [AnimeStaffOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeStaffCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeStaffFilter
  ): AnimeStaffConnection

  """Reads and enables pagination through a set of `AnimeStreamingOn`."""
  animeStreamingOns(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeStreamingOn`."""
    orderBy: [AnimeStreamingOnsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeStreamingOnCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeStreamingOnFilter
  ): AnimeStreamingOnsConnection

  """Reads and enables pagination through a set of `AnimeStudio`."""
  animeStudios(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeStudio`."""
    orderBy: [AnimeStudiosOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeStudioCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeStudioFilter
  ): AnimeStudiosConnection

  """Reads and enables pagination through a set of `AnimeUserScore`."""
  animeUserScores(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeUserScore`."""
    orderBy: [AnimeUserScoresOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeUserScoreCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeUserScoreFilter
  ): AnimeUserScoresConnection

  """Reads and enables pagination through a set of `Anime`."""
  animes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Anime`."""
    orderBy: [AnimeOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeFilter
  ): AnimeConnection

  """Reads and enables pagination through a set of `AvailableLanguage`."""
  availableLanguages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AvailableLanguage`."""
    orderBy: [AvailableLanguagesOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AvailableLanguageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AvailableLanguageFilter
  ): AvailableLanguagesConnection

  """Reads and enables pagination through a set of `CharacterImage`."""
  characterImages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CharacterImage`."""
    orderBy: [CharacterImagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CharacterImageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CharacterImageFilter
  ): CharacterImagesConnection

  """Reads and enables pagination through a set of `CharacterRole`."""
  characterRoles(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CharacterRole`."""
    orderBy: [CharacterRolesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CharacterRoleCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CharacterRoleFilter
  ): CharacterRolesConnection

  """Reads and enables pagination through a set of `Character`."""
  characters(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Character`."""
    orderBy: [CharactersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CharacterCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CharacterFilter
  ): CharactersConnection

  """Reads and enables pagination through a set of `Genre`."""
  genres(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Genre`."""
    orderBy: [GenresOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GenreCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GenreFilter
  ): GenresConnection

  """Reads and enables pagination through a set of `Image`."""
  images(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Image`."""
    orderBy: [ImagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ImageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ImageFilter
  ): ImagesConnection

  """Reads and enables pagination through a set of `Licensor`."""
  licensors(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Licensor`."""
    orderBy: [LicensorsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LicensorCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: LicensorFilter
  ): LicensorsConnection

  """Reads and enables pagination through a set of `MediaFormat`."""
  mediaFormats(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MediaFormat`."""
    orderBy: [MediaFormatsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MediaFormatCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MediaFormatFilter
  ): MediaFormatsConnection

  """Reads and enables pagination through a set of `PersonImage`."""
  personImages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PersonImage`."""
    orderBy: [PersonImagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PersonImageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PersonImageFilter
  ): PersonImagesConnection

  """Reads and enables pagination through a set of `Person`."""
  people(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Person`."""
    orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PersonCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PersonFilter
  ): PeopleConnection

  """Reads and enables pagination through a set of `Producer`."""
  producers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Producer`."""
    orderBy: [ProducersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProducerCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProducerFilter
  ): ProducersConnection

  """Reads and enables pagination through a set of `SourceMaterial`."""
  sourceMaterials(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `SourceMaterial`."""
    orderBy: [SourceMaterialsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SourceMaterialCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SourceMaterialFilter
  ): SourceMaterialsConnection

  """Reads and enables pagination through a set of `StaffRole`."""
  staffRoles(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StaffRole`."""
    orderBy: [StaffRolesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StaffRoleCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: StaffRoleFilter
  ): StaffRolesConnection

  """Reads and enables pagination through a set of `Studio`."""
  studios(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Studio`."""
    orderBy: [StudiosOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StudioCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: StudioFilter
  ): StudiosConnection

  """Reads and enables pagination through a set of `UserAnime`."""
  userAnimes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserAnime`."""
    orderBy: [UserAnimeOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserAnimeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserAnimeFilter
  ): UserAnimeConnection

  """Reads and enables pagination through a set of `UserAnimeList`."""
  userAnimeLists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserAnimeList`."""
    orderBy: [UserAnimeListsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserAnimeListCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserAnimeListFilter
  ): UserAnimeListsConnection

  """Reads and enables pagination through a set of `UserNotification`."""
  userNotifications(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserNotification`."""
    orderBy: [UserNotificationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserNotificationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserNotificationFilter
  ): UserNotificationsConnection

  """Reads and enables pagination through a set of `UserWatchStatus`."""
  userWatchStatuses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserWatchStatus`."""
    orderBy: [UserWatchStatusesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserWatchStatusCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserWatchStatusFilter
  ): UserWatchStatusesConnection

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): UsersConnection
  alternateAnimeName(id: UUID!): AlternateAnimeName
  animeCharacter(animeId: UUID!, characterId: UUID!, personId: UUID!, characterRoleId: UUID!, language: LanguageType!): AnimeCharacter
  animeGenre(animeId: UUID!, genreId: UUID!): AnimeGenre
  animeImage(animeId: UUID!, imageId: UUID!): AnimeImage
  animeLicensor(animeId: UUID!, licensorId: UUID!): AnimeLicensor
  animeList(id: UUID!): AnimeList
  animeProducer(animeId: UUID!, producerId: UUID!): AnimeProducer
  animeStaff(animeId: UUID!, personId: UUID!, staffRoleId: UUID!): AnimeStaff
  animeStreamingOn(animeId: UUID!, streamServiceId: StreamingServices!): AnimeStreamingOn
  animeStudio(animeId: UUID!, studioId: UUID!): AnimeStudio
  animeUserScore(animeId: UUID!, userId: String!): AnimeUserScore
  anime(id: UUID!): Anime
  animeByMalId(malId: Int!): Anime
  characterImage(characterId: UUID!, imageId: UUID!): CharacterImage
  characterRole(id: UUID!): CharacterRole
  characterRoleByRole(role: String!): CharacterRole
  character(id: UUID!): Character
  characterByMalId(malId: String!): Character
  genre(id: UUID!): Genre
  genreByGenre(genre: String!): Genre
  image(id: UUID!): Image
  licensor(id: UUID!): Licensor
  licensorByLicensor(licensor: String!): Licensor
  personImage(personId: UUID!, imageId: UUID!): PersonImage
  person(id: UUID!): Person
  personByMalId(malId: String!): Person
  producer(id: UUID!): Producer
  producerByProducer(producer: String!): Producer
  staffRole(id: UUID!): StaffRole
  staffRoleByRole(role: String!): StaffRole
  studio(id: UUID!): Studio
  studioByStudio(studio: String!): Studio
  userAnime(animeId: UUID!, userId: String!): UserAnime
  userAnimeListByAnimeListIdAndAnimeId(animeListId: UUID!, animeId: UUID!): UserAnimeList
  userNotification(id: UUID!): UserNotification
  userWatchStatus(userId: String!, animeId: UUID!): UserWatchStatus
  user(id: String!): User

  """Reads and enables pagination through a set of `UserAnimeListType`."""
  allUserAnimes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserAnimeListTypeFilter
  ): UserAnimeListTypesConnection
  currentRole: String
  currentUser: String

  """Reads and enables pagination through a set of `UserList`."""
  getUserAnimeLists(
    watchStatusInput: String

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserListFilter
  ): UserListsConnection
  isUsernameTaken(usernameInput: String): Boolean
  me: MeType

  """Reads and enables pagination through a set of `SearchResult`."""
  searchAnimes(
    searchInput: String

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SearchResultFilter
  ): SearchResultsConnection

  """Reads and enables pagination through a set of `CustomAnimeList`."""
  userCustomAnimeList(
    listId: UUID

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CustomAnimeListFilter
  ): CustomAnimeListsConnection

  """
  Reads and enables pagination through a set of `UserCustomAnimeListByStatusType`.
  """
  userCustomAnimeListByStatus(
    watchStatusType: String

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserCustomAnimeListByStatusTypeFilter
  ): UserCustomAnimeListByStatusTypesConnection

  """Reads a single `AlternateAnimeName` using its globally unique `ID`."""
  alternateAnimeNameByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `AlternateAnimeName`.
    """
    nodeId: ID!
  ): AlternateAnimeName

  """Reads a single `AnimeCharacter` using its globally unique `ID`."""
  animeCharacterByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `AnimeCharacter`.
    """
    nodeId: ID!
  ): AnimeCharacter

  """Reads a single `AnimeGenre` using its globally unique `ID`."""
  animeGenreByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `AnimeGenre`.
    """
    nodeId: ID!
  ): AnimeGenre

  """Reads a single `AnimeImage` using its globally unique `ID`."""
  animeImageByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `AnimeImage`.
    """
    nodeId: ID!
  ): AnimeImage

  """Reads a single `AnimeLicensor` using its globally unique `ID`."""
  animeLicensorByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `AnimeLicensor`.
    """
    nodeId: ID!
  ): AnimeLicensor

  """Reads a single `AnimeList` using its globally unique `ID`."""
  animeListByNodeId(
    """The globally unique `ID` to be used in selecting a single `AnimeList`."""
    nodeId: ID!
  ): AnimeList

  """Reads a single `AnimeProducer` using its globally unique `ID`."""
  animeProducerByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `AnimeProducer`.
    """
    nodeId: ID!
  ): AnimeProducer

  """Reads a single `AnimeStaff` using its globally unique `ID`."""
  animeStaffByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `AnimeStaff`.
    """
    nodeId: ID!
  ): AnimeStaff

  """Reads a single `AnimeStreamingOn` using its globally unique `ID`."""
  animeStreamingOnByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `AnimeStreamingOn`.
    """
    nodeId: ID!
  ): AnimeStreamingOn

  """Reads a single `AnimeStudio` using its globally unique `ID`."""
  animeStudioByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `AnimeStudio`.
    """
    nodeId: ID!
  ): AnimeStudio

  """Reads a single `AnimeUserScore` using its globally unique `ID`."""
  animeUserScoreByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `AnimeUserScore`.
    """
    nodeId: ID!
  ): AnimeUserScore

  """Reads a single `Anime` using its globally unique `ID`."""
  animeByNodeId(
    """The globally unique `ID` to be used in selecting a single `Anime`."""
    nodeId: ID!
  ): Anime

  """Reads a single `CharacterImage` using its globally unique `ID`."""
  characterImageByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CharacterImage`.
    """
    nodeId: ID!
  ): CharacterImage

  """Reads a single `CharacterRole` using its globally unique `ID`."""
  characterRoleByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CharacterRole`.
    """
    nodeId: ID!
  ): CharacterRole

  """Reads a single `Character` using its globally unique `ID`."""
  characterByNodeId(
    """The globally unique `ID` to be used in selecting a single `Character`."""
    nodeId: ID!
  ): Character

  """Reads a single `Genre` using its globally unique `ID`."""
  genreByNodeId(
    """The globally unique `ID` to be used in selecting a single `Genre`."""
    nodeId: ID!
  ): Genre

  """Reads a single `Image` using its globally unique `ID`."""
  imageByNodeId(
    """The globally unique `ID` to be used in selecting a single `Image`."""
    nodeId: ID!
  ): Image

  """Reads a single `Licensor` using its globally unique `ID`."""
  licensorByNodeId(
    """The globally unique `ID` to be used in selecting a single `Licensor`."""
    nodeId: ID!
  ): Licensor

  """Reads a single `PersonImage` using its globally unique `ID`."""
  personImageByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `PersonImage`.
    """
    nodeId: ID!
  ): PersonImage

  """Reads a single `Person` using its globally unique `ID`."""
  personByNodeId(
    """The globally unique `ID` to be used in selecting a single `Person`."""
    nodeId: ID!
  ): Person

  """Reads a single `Producer` using its globally unique `ID`."""
  producerByNodeId(
    """The globally unique `ID` to be used in selecting a single `Producer`."""
    nodeId: ID!
  ): Producer

  """Reads a single `StaffRole` using its globally unique `ID`."""
  staffRoleByNodeId(
    """The globally unique `ID` to be used in selecting a single `StaffRole`."""
    nodeId: ID!
  ): StaffRole

  """Reads a single `Studio` using its globally unique `ID`."""
  studioByNodeId(
    """The globally unique `ID` to be used in selecting a single `Studio`."""
    nodeId: ID!
  ): Studio

  """Reads a single `UserAnime` using its globally unique `ID`."""
  userAnimeByNodeId(
    """The globally unique `ID` to be used in selecting a single `UserAnime`."""
    nodeId: ID!
  ): UserAnime

  """Reads a single `UserNotification` using its globally unique `ID`."""
  userNotificationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `UserNotification`.
    """
    nodeId: ID!
  ): UserNotification

  """Reads a single `UserWatchStatus` using its globally unique `ID`."""
  userWatchStatusByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `UserWatchStatus`.
    """
    nodeId: ID!
  ): UserWatchStatus

  """Reads a single `User` using its globally unique `ID`."""
  userByNodeId(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `AgeRating` values."""
type AgeRatingsConnection {
  """A list of `AgeRating` objects."""
  nodes: [AgeRating!]!

  """
  A list of edges which contains the `AgeRating` and cursor to aid in pagination.
  """
  edges: [AgeRatingsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AgeRating` you could get from the connection."""
  totalCount: Int!
}

type AgeRating {
  ageRatingType: String
  id: BigInt
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""A `AgeRating` edge in the connection."""
type AgeRatingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AgeRating` at the end of the edge."""
  node: AgeRating!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""Methods to use when ordering `AgeRating`."""
enum AgeRatingsOrderBy {
  NATURAL
  AGE_RATING_TYPE_ASC
  AGE_RATING_TYPE_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against `AgeRating` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input AgeRatingCondition {
  """Checks for equality with the object’s `ageRatingType` field."""
  ageRatingType: String

  """Checks for equality with the object’s `id` field."""
  id: BigInt
}

"""
A filter to be used against `AgeRating` object types. All fields are combined with a logical ‘and.’
"""
input AgeRatingFilter {
  """Filter by the object’s `ageRatingType` field."""
  ageRatingType: StringFilter

  """Filter by the object’s `id` field."""
  id: BigIntFilter

  """Checks for all expressions in this list."""
  and: [AgeRatingFilter!]

  """Checks for any expressions in this list."""
  or: [AgeRatingFilter!]

  """Negates the expression."""
  not: AgeRatingFilter
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String
}

"""
A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’
"""
input BigIntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigInt

  """Not equal to the specified value."""
  notEqualTo: BigInt

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigInt

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigInt

  """Included in the specified list."""
  in: [BigInt!]

  """Not included in the specified list."""
  notIn: [BigInt!]

  """Less than the specified value."""
  lessThan: BigInt

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigInt

  """Greater than the specified value."""
  greaterThan: BigInt

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigInt
}

"""A connection to a list of `AiringStatus` values."""
type AiringStatusesConnection {
  """A list of `AiringStatus` objects."""
  nodes: [AiringStatus!]!

  """
  A list of edges which contains the `AiringStatus` and cursor to aid in pagination.
  """
  edges: [AiringStatusesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AiringStatus` you could get from the connection."""
  totalCount: Int!
}

type AiringStatus {
  airingStatusType: String
  id: BigInt
}

"""A `AiringStatus` edge in the connection."""
type AiringStatusesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AiringStatus` at the end of the edge."""
  node: AiringStatus!
}

"""Methods to use when ordering `AiringStatus`."""
enum AiringStatusesOrderBy {
  NATURAL
  AIRING_STATUS_TYPE_ASC
  AIRING_STATUS_TYPE_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against `AiringStatus` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input AiringStatusCondition {
  """Checks for equality with the object’s `airingStatusType` field."""
  airingStatusType: String

  """Checks for equality with the object’s `id` field."""
  id: BigInt
}

"""
A filter to be used against `AiringStatus` object types. All fields are combined with a logical ‘and.’
"""
input AiringStatusFilter {
  """Filter by the object’s `airingStatusType` field."""
  airingStatusType: StringFilter

  """Filter by the object’s `id` field."""
  id: BigIntFilter

  """Checks for all expressions in this list."""
  and: [AiringStatusFilter!]

  """Checks for any expressions in this list."""
  or: [AiringStatusFilter!]

  """Negates the expression."""
  not: AiringStatusFilter
}

"""A connection to a list of `AlternateAnimeName` values."""
type AlternateAnimeNamesConnection {
  """A list of `AlternateAnimeName` objects."""
  nodes: [AlternateAnimeName!]!

  """
  A list of edges which contains the `AlternateAnimeName` and cursor to aid in pagination.
  """
  edges: [AlternateAnimeNamesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `AlternateAnimeName` you could get from the connection.
  """
  totalCount: Int!
}

type AlternateAnimeName implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  name: String!

  """Reads a single `Anime` that is related to this `AlternateAnimeName`."""
  anime: Anime
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

type Anime implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  malId: Int
  title: String!
  description: String
  numberOfEpisodes: Int
  duration: Int
  averageWatcherRating: BigFloat
  startBroadcastDatetime: Datetime
  endBroadcastDatetime: Datetime
  ageRatingType: AgeRatingTypes
  airingStatusType: AiringStatusTypes
  mediaType: MediaTypes
  sourceMaterialType: SourceMaterialTypes
  coverImage: String
  season: Season
  seasonYear: Int
  youtubeTrailerId: String
  twitterHandle: String
  officialWebsite: String

  """Reads and enables pagination through a set of `UserAnimeList`."""
  userAnimeLists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserAnimeList`."""
    orderBy: [UserAnimeListsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserAnimeListCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserAnimeListFilter
  ): UserAnimeListsConnection!

  """Reads and enables pagination through a set of `AnimeUserScore`."""
  animeUserScores(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeUserScore`."""
    orderBy: [AnimeUserScoresOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeUserScoreCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeUserScoreFilter
  ): AnimeUserScoresConnection!

  """Reads and enables pagination through a set of `AlternateAnimeName`."""
  alternateAnimeNames(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AlternateAnimeName`."""
    orderBy: [AlternateAnimeNamesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AlternateAnimeNameCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AlternateAnimeNameFilter
  ): AlternateAnimeNamesConnection!

  """Reads and enables pagination through a set of `AnimeCharacter`."""
  animeCharacters(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeCharacter`."""
    orderBy: [AnimeCharactersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeCharacterCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeCharacterFilter
  ): AnimeCharactersConnection!

  """Reads and enables pagination through a set of `AnimeGenre`."""
  animeGenres(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeGenre`."""
    orderBy: [AnimeGenresOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeGenreCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeGenreFilter
  ): AnimeGenresConnection!

  """Reads and enables pagination through a set of `AnimeImage`."""
  animeImages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeImage`."""
    orderBy: [AnimeImagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeImageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeImageFilter
  ): AnimeImagesConnection!

  """Reads and enables pagination through a set of `AnimeLicensor`."""
  animeLicensors(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeLicensor`."""
    orderBy: [AnimeLicensorsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeLicensorCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeLicensorFilter
  ): AnimeLicensorsConnection!

  """Reads and enables pagination through a set of `AnimeProducer`."""
  animeProducers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeProducer`."""
    orderBy: [AnimeProducersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeProducerCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeProducerFilter
  ): AnimeProducersConnection!

  """Reads and enables pagination through a set of `AnimeStaff`."""
  animeStaffs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeStaff`."""
    orderBy: [AnimeStaffOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeStaffCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeStaffFilter
  ): AnimeStaffConnection!

  """Reads and enables pagination through a set of `AnimeStudio`."""
  animeStudios(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeStudio`."""
    orderBy: [AnimeStudiosOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeStudioCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeStudioFilter
  ): AnimeStudiosConnection!

  """Reads and enables pagination through a set of `UserAnime`."""
  userAnimes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserAnime`."""
    orderBy: [UserAnimeOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserAnimeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserAnimeFilter
  ): UserAnimeConnection!

  """Reads and enables pagination through a set of `UserWatchStatus`."""
  userWatchStatuses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserWatchStatus`."""
    orderBy: [UserWatchStatusesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserWatchStatusCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserWatchStatusFilter
  ): UserWatchStatusesConnection!

  """Reads and enables pagination through a set of `AnimeStreamingOn`."""
  animeStreamingOns(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeStreamingOn`."""
    orderBy: [AnimeStreamingOnsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeStreamingOnCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeStreamingOnFilter
  ): AnimeStreamingOnsConnection!
  allNamesString: String

  """Reads and enables pagination through a set of `AlternateAnimeName`."""
  alternateNames(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AlternateAnimeNameFilter
  ): AlternateAnimeNamesConnection!

  """Reads and enables pagination through a set of `StaffResult`."""
  characterPreview(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: StaffResultFilter
  ): StaffResultsConnection!

  """Reads and enables pagination through a set of `Genre`."""
  genreList(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GenreFilter
  ): GenresConnection!

  """Reads and enables pagination through a set of `Licensor`."""
  licensorList(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: LicensorFilter
  ): LicensorsConnection!

  """Reads and enables pagination through a set of `Producer`."""
  producerList(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProducerFilter
  ): ProducersConnection!

  """Reads and enables pagination through a set of `Studio`."""
  studioList(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: StudioFilter
  ): StudiosConnection!
  userEpisodeCount: BigFloat
  userLiked: Boolean
  userRating: BigFloat
  userWatchStatus: String
}

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

enum AgeRatingTypes {
  PG_13_TEENS_13_OR_OLDER
  R_17_VIOLENCE_PROFANITY_
  R_MILD_NUDITY
  G_ALL_AGES
  PG_CHILDREN
}

enum AiringStatusTypes {
  FINISHED_AIRING
  CURRENTLY_AIRING
}

enum MediaTypes {
  TV
  OVA
  MOVIE
  ONA
  SPECIAL
}

enum SourceMaterialTypes {
  MANGA
  NOVEL
  VISUAL_NOVEL
  ORIGINAL
  WEB_MANGA
  LIGHT_NOVEL
}

enum Season {
  SUMMER
  UNKNOWN
  SPRING
  FALL
  WINTER
}

"""A connection to a list of `UserAnimeList` values."""
type UserAnimeListsConnection {
  """A list of `UserAnimeList` objects."""
  nodes: [UserAnimeList!]!

  """
  A list of edges which contains the `UserAnimeList` and cursor to aid in pagination.
  """
  edges: [UserAnimeListsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `UserAnimeList` you could get from the connection."""
  totalCount: Int!
}

type UserAnimeList {
  animeIndex: String!

  """Reads a single `AnimeList` that is related to this `UserAnimeList`."""
  animeList: AnimeList

  """Reads a single `Anime` that is related to this `UserAnimeList`."""
  anime: Anime
}

type AnimeList implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  title: String!
  privacy: AnimeListPrivacy!
  isDefault: Boolean
  createdAt: Datetime

  """Reads a single `User` that is related to this `AnimeList`."""
  user: User

  """Reads and enables pagination through a set of `UserAnimeList`."""
  userAnimeLists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserAnimeList`."""
    orderBy: [UserAnimeListsOrderBy!] = [NATURAL]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserAnimeListCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserAnimeListFilter
  ): UserAnimeListsConnection!
}

enum AnimeListPrivacy {
  PUBLIC
  PRIVATE
  FRIENDS_ONLY
}

type User implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!

  """Reads and enables pagination through a set of `AnimeList`."""
  animeLists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeList`."""
    orderBy: [AnimeListsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeListCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeListFilter
  ): AnimeListsConnection!

  """Reads and enables pagination through a set of `AnimeUserScore`."""
  animeUserScores(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeUserScore`."""
    orderBy: [AnimeUserScoresOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeUserScoreCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeUserScoreFilter
  ): AnimeUserScoresConnection!

  """Reads and enables pagination through a set of `UserAnime`."""
  userAnimes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserAnime`."""
    orderBy: [UserAnimeOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserAnimeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserAnimeFilter
  ): UserAnimeConnection!

  """Reads and enables pagination through a set of `UserWatchStatus`."""
  userWatchStatuses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserWatchStatus`."""
    orderBy: [UserWatchStatusesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserWatchStatusCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserWatchStatusFilter
  ): UserWatchStatusesConnection!

  """Reads and enables pagination through a set of `UserNotification`."""
  userNotifications(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UserNotification`."""
    orderBy: [UserNotificationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserNotificationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserNotificationFilter
  ): UserNotificationsConnection!
}

"""A connection to a list of `AnimeList` values."""
type AnimeListsConnection {
  """A list of `AnimeList` objects."""
  nodes: [AnimeList!]!

  """
  A list of edges which contains the `AnimeList` and cursor to aid in pagination.
  """
  edges: [AnimeListsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AnimeList` you could get from the connection."""
  totalCount: Int!
}

"""A `AnimeList` edge in the connection."""
type AnimeListsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AnimeList` at the end of the edge."""
  node: AnimeList!
}

"""Methods to use when ordering `AnimeList`."""
enum AnimeListsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  TITLE_ASC
  TITLE_DESC
  PRIVACY_ASC
  PRIVACY_DESC
  IS_DEFAULT_ASC
  IS_DEFAULT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_BY_USER_ID__ID_ASC
  USER_BY_USER_ID__ID_DESC
  USER_ANIME_LISTS_BY_ANIME_LIST_ID__COUNT_ASC
  USER_ANIME_LISTS_BY_ANIME_LIST_ID__COUNT_DESC
}

"""
A condition to be used against `AnimeList` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input AnimeListCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `privacy` field."""
  privacy: AnimeListPrivacy

  """Checks for equality with the object’s `isDefault` field."""
  isDefault: Boolean

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime
}

"""
A filter to be used against `AnimeList` object types. All fields are combined with a logical ‘and.’
"""
input AnimeListFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `privacy` field."""
  privacy: AnimeListPrivacyFilter

  """Filter by the object’s `isDefault` field."""
  isDefault: BooleanFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Checks for all expressions in this list."""
  and: [AnimeListFilter!]

  """Checks for any expressions in this list."""
  or: [AnimeListFilter!]

  """Negates the expression."""
  not: AnimeListFilter
}

"""
A filter to be used against UUID fields. All fields are combined with a logical ‘and.’
"""
input UUIDFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: UUID

  """Not equal to the specified value."""
  notEqualTo: UUID

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: UUID

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: UUID

  """Included in the specified list."""
  in: [UUID!]

  """Not included in the specified list."""
  notIn: [UUID!]

  """Less than the specified value."""
  lessThan: UUID

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: UUID

  """Greater than the specified value."""
  greaterThan: UUID

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: UUID
}

"""
A filter to be used against AnimeListPrivacy fields. All fields are combined with a logical ‘and.’
"""
input AnimeListPrivacyFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: AnimeListPrivacy

  """Not equal to the specified value."""
  notEqualTo: AnimeListPrivacy

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: AnimeListPrivacy

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: AnimeListPrivacy

  """Included in the specified list."""
  in: [AnimeListPrivacy!]

  """Not included in the specified list."""
  notIn: [AnimeListPrivacy!]

  """Less than the specified value."""
  lessThan: AnimeListPrivacy

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: AnimeListPrivacy

  """Greater than the specified value."""
  greaterThan: AnimeListPrivacy

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: AnimeListPrivacy
}

"""
A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’
"""
input BooleanFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Boolean

  """Not equal to the specified value."""
  notEqualTo: Boolean

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Boolean

  """Included in the specified list."""
  in: [Boolean!]

  """Not included in the specified list."""
  notIn: [Boolean!]

  """Less than the specified value."""
  lessThan: Boolean

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Boolean

  """Greater than the specified value."""
  greaterThan: Boolean

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Boolean
}

"""
A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
"""
input DatetimeFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Datetime

  """Not equal to the specified value."""
  notEqualTo: Datetime

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Datetime

  """Included in the specified list."""
  in: [Datetime!]

  """Not included in the specified list."""
  notIn: [Datetime!]

  """Less than the specified value."""
  lessThan: Datetime

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Datetime

  """Greater than the specified value."""
  greaterThan: Datetime

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Datetime
}

"""A connection to a list of `AnimeUserScore` values."""
type AnimeUserScoresConnection {
  """A list of `AnimeUserScore` objects."""
  nodes: [AnimeUserScore!]!

  """
  A list of edges which contains the `AnimeUserScore` and cursor to aid in pagination.
  """
  edges: [AnimeUserScoresEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AnimeUserScore` you could get from the connection."""
  totalCount: Int!
}

type AnimeUserScore implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  animeId: UUID!
  userId: String!
  userScore: BigFloat!

  """Reads a single `Anime` that is related to this `AnimeUserScore`."""
  anime: Anime

  """Reads a single `User` that is related to this `AnimeUserScore`."""
  user: User
}

"""A `AnimeUserScore` edge in the connection."""
type AnimeUserScoresEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AnimeUserScore` at the end of the edge."""
  node: AnimeUserScore!
}

"""Methods to use when ordering `AnimeUserScore`."""
enum AnimeUserScoresOrderBy {
  NATURAL
  ANIME_ID_ASC
  ANIME_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  USER_SCORE_ASC
  USER_SCORE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_BY_ANIME_ID__ID_ASC
  ANIME_BY_ANIME_ID__ID_DESC
  ANIME_BY_ANIME_ID__MAL_ID_ASC
  ANIME_BY_ANIME_ID__MAL_ID_DESC
  ANIME_BY_ANIME_ID__TITLE_ASC
  ANIME_BY_ANIME_ID__TITLE_DESC
  ANIME_BY_ANIME_ID__DESCRIPTION_ASC
  ANIME_BY_ANIME_ID__DESCRIPTION_DESC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_ASC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_DESC
  ANIME_BY_ANIME_ID__DURATION_ASC
  ANIME_BY_ANIME_ID__DURATION_DESC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_ASC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_DESC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_ASC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_DESC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_ASC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_DESC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_ASC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_DESC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_ASC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_DESC
  ANIME_BY_ANIME_ID__COVER_IMAGE_ASC
  ANIME_BY_ANIME_ID__COVER_IMAGE_DESC
  ANIME_BY_ANIME_ID__SEASON_ASC
  ANIME_BY_ANIME_ID__SEASON_DESC
  ANIME_BY_ANIME_ID__SEASON_YEAR_ASC
  ANIME_BY_ANIME_ID__SEASON_YEAR_DESC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_ASC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_DESC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_ASC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_DESC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_ASC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_DESC
  USER_BY_USER_ID__ID_ASC
  USER_BY_USER_ID__ID_DESC
}

"""
A condition to be used against `AnimeUserScore` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input AnimeUserScoreCondition {
  """Checks for equality with the object’s `animeId` field."""
  animeId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `userScore` field."""
  userScore: BigFloat
}

"""
A filter to be used against `AnimeUserScore` object types. All fields are combined with a logical ‘and.’
"""
input AnimeUserScoreFilter {
  """Filter by the object’s `animeId` field."""
  animeId: UUIDFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `userScore` field."""
  userScore: BigFloatFilter

  """Checks for all expressions in this list."""
  and: [AnimeUserScoreFilter!]

  """Checks for any expressions in this list."""
  or: [AnimeUserScoreFilter!]

  """Negates the expression."""
  not: AnimeUserScoreFilter
}

"""
A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’
"""
input BigFloatFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigFloat

  """Not equal to the specified value."""
  notEqualTo: BigFloat

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigFloat

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigFloat

  """Included in the specified list."""
  in: [BigFloat!]

  """Not included in the specified list."""
  notIn: [BigFloat!]

  """Less than the specified value."""
  lessThan: BigFloat

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigFloat

  """Greater than the specified value."""
  greaterThan: BigFloat

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigFloat
}

"""A connection to a list of `UserAnime` values."""
type UserAnimeConnection {
  """A list of `UserAnime` objects."""
  nodes: [UserAnime!]!

  """
  A list of edges which contains the `UserAnime` and cursor to aid in pagination.
  """
  edges: [UserAnimeEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `UserAnime` you could get from the connection."""
  totalCount: Int!
}

type UserAnime implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  animeId: UUID!
  userId: String!

  """Reads a single `Anime` that is related to this `UserAnime`."""
  anime: Anime

  """Reads a single `User` that is related to this `UserAnime`."""
  user: User
}

"""A `UserAnime` edge in the connection."""
type UserAnimeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserAnime` at the end of the edge."""
  node: UserAnime!
}

"""Methods to use when ordering `UserAnime`."""
enum UserAnimeOrderBy {
  NATURAL
  ANIME_ID_ASC
  ANIME_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_BY_ANIME_ID__ID_ASC
  ANIME_BY_ANIME_ID__ID_DESC
  ANIME_BY_ANIME_ID__MAL_ID_ASC
  ANIME_BY_ANIME_ID__MAL_ID_DESC
  ANIME_BY_ANIME_ID__TITLE_ASC
  ANIME_BY_ANIME_ID__TITLE_DESC
  ANIME_BY_ANIME_ID__DESCRIPTION_ASC
  ANIME_BY_ANIME_ID__DESCRIPTION_DESC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_ASC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_DESC
  ANIME_BY_ANIME_ID__DURATION_ASC
  ANIME_BY_ANIME_ID__DURATION_DESC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_ASC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_DESC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_ASC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_DESC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_ASC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_DESC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_ASC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_DESC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_ASC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_DESC
  ANIME_BY_ANIME_ID__COVER_IMAGE_ASC
  ANIME_BY_ANIME_ID__COVER_IMAGE_DESC
  ANIME_BY_ANIME_ID__SEASON_ASC
  ANIME_BY_ANIME_ID__SEASON_DESC
  ANIME_BY_ANIME_ID__SEASON_YEAR_ASC
  ANIME_BY_ANIME_ID__SEASON_YEAR_DESC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_ASC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_DESC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_ASC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_DESC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_ASC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_DESC
  USER_BY_USER_ID__ID_ASC
  USER_BY_USER_ID__ID_DESC
}

"""
A condition to be used against `UserAnime` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input UserAnimeCondition {
  """Checks for equality with the object’s `animeId` field."""
  animeId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: String
}

"""
A filter to be used against `UserAnime` object types. All fields are combined with a logical ‘and.’
"""
input UserAnimeFilter {
  """Filter by the object’s `animeId` field."""
  animeId: UUIDFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Checks for all expressions in this list."""
  and: [UserAnimeFilter!]

  """Checks for any expressions in this list."""
  or: [UserAnimeFilter!]

  """Negates the expression."""
  not: UserAnimeFilter
}

"""A connection to a list of `UserWatchStatus` values."""
type UserWatchStatusesConnection {
  """A list of `UserWatchStatus` objects."""
  nodes: [UserWatchStatus!]!

  """
  A list of edges which contains the `UserWatchStatus` and cursor to aid in pagination.
  """
  edges: [UserWatchStatusesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `UserWatchStatus` you could get from the connection.
  """
  totalCount: Int!
}

type UserWatchStatus implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  userId: String!
  animeId: UUID!
  userEpisodesWatched: Int!
  watchStatus: WatchStatusTypes

  """Reads a single `User` that is related to this `UserWatchStatus`."""
  user: User

  """Reads a single `Anime` that is related to this `UserWatchStatus`."""
  anime: Anime
}

enum WatchStatusTypes {
  NOT_WATCHED
  PLAN_TO_WATCH
  WATCHING
  PAUSED
  COMPLETED
  DROPPED
  REWATCHING
}

"""A `UserWatchStatus` edge in the connection."""
type UserWatchStatusesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserWatchStatus` at the end of the edge."""
  node: UserWatchStatus!
}

"""Methods to use when ordering `UserWatchStatus`."""
enum UserWatchStatusesOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  ANIME_ID_ASC
  ANIME_ID_DESC
  USER_EPISODES_WATCHED_ASC
  USER_EPISODES_WATCHED_DESC
  WATCH_STATUS_ASC
  WATCH_STATUS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_BY_USER_ID__ID_ASC
  USER_BY_USER_ID__ID_DESC
  ANIME_BY_ANIME_ID__ID_ASC
  ANIME_BY_ANIME_ID__ID_DESC
  ANIME_BY_ANIME_ID__MAL_ID_ASC
  ANIME_BY_ANIME_ID__MAL_ID_DESC
  ANIME_BY_ANIME_ID__TITLE_ASC
  ANIME_BY_ANIME_ID__TITLE_DESC
  ANIME_BY_ANIME_ID__DESCRIPTION_ASC
  ANIME_BY_ANIME_ID__DESCRIPTION_DESC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_ASC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_DESC
  ANIME_BY_ANIME_ID__DURATION_ASC
  ANIME_BY_ANIME_ID__DURATION_DESC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_ASC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_DESC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_ASC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_DESC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_ASC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_DESC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_ASC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_DESC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_ASC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_DESC
  ANIME_BY_ANIME_ID__COVER_IMAGE_ASC
  ANIME_BY_ANIME_ID__COVER_IMAGE_DESC
  ANIME_BY_ANIME_ID__SEASON_ASC
  ANIME_BY_ANIME_ID__SEASON_DESC
  ANIME_BY_ANIME_ID__SEASON_YEAR_ASC
  ANIME_BY_ANIME_ID__SEASON_YEAR_DESC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_ASC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_DESC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_ASC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_DESC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_ASC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_DESC
}

"""
A condition to be used against `UserWatchStatus` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input UserWatchStatusCondition {
  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `animeId` field."""
  animeId: UUID

  """Checks for equality with the object’s `userEpisodesWatched` field."""
  userEpisodesWatched: Int

  """Checks for equality with the object’s `watchStatus` field."""
  watchStatus: WatchStatusTypes
}

"""
A filter to be used against `UserWatchStatus` object types. All fields are combined with a logical ‘and.’
"""
input UserWatchStatusFilter {
  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `animeId` field."""
  animeId: UUIDFilter

  """Filter by the object’s `userEpisodesWatched` field."""
  userEpisodesWatched: IntFilter

  """Filter by the object’s `watchStatus` field."""
  watchStatus: WatchStatusTypesFilter

  """Checks for all expressions in this list."""
  and: [UserWatchStatusFilter!]

  """Checks for any expressions in this list."""
  or: [UserWatchStatusFilter!]

  """Negates the expression."""
  not: UserWatchStatusFilter
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Int

  """Not equal to the specified value."""
  notEqualTo: Int

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int

  """Included in the specified list."""
  in: [Int!]

  """Not included in the specified list."""
  notIn: [Int!]

  """Less than the specified value."""
  lessThan: Int

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int

  """Greater than the specified value."""
  greaterThan: Int

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int
}

"""
A filter to be used against WatchStatusTypes fields. All fields are combined with a logical ‘and.’
"""
input WatchStatusTypesFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: WatchStatusTypes

  """Not equal to the specified value."""
  notEqualTo: WatchStatusTypes

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: WatchStatusTypes

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: WatchStatusTypes

  """Included in the specified list."""
  in: [WatchStatusTypes!]

  """Not included in the specified list."""
  notIn: [WatchStatusTypes!]

  """Less than the specified value."""
  lessThan: WatchStatusTypes

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: WatchStatusTypes

  """Greater than the specified value."""
  greaterThan: WatchStatusTypes

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: WatchStatusTypes
}

"""A connection to a list of `UserNotification` values."""
type UserNotificationsConnection {
  """A list of `UserNotification` objects."""
  nodes: [UserNotification!]!

  """
  A list of edges which contains the `UserNotification` and cursor to aid in pagination.
  """
  edges: [UserNotificationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `UserNotification` you could get from the connection.
  """
  totalCount: Int!
}

type UserNotification implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  isRead: Boolean
  notificationType: NotificationType!
  createdAt: Datetime
  message: String
  entityId: UUID!
  entityImage: String

  """Reads a single `User` that is related to this `UserNotification`."""
  user: User
}

enum NotificationType {
  """an anime is airing a new episode"""
  AIRING
}

"""A `UserNotification` edge in the connection."""
type UserNotificationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserNotification` at the end of the edge."""
  node: UserNotification!
}

"""Methods to use when ordering `UserNotification`."""
enum UserNotificationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  IS_READ_ASC
  IS_READ_DESC
  NOTIFICATION_TYPE_ASC
  NOTIFICATION_TYPE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  MESSAGE_ASC
  MESSAGE_DESC
  ENTITY_ID_ASC
  ENTITY_ID_DESC
  ENTITY_IMAGE_ASC
  ENTITY_IMAGE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_BY_USER_ID__ID_ASC
  USER_BY_USER_ID__ID_DESC
}

"""
A condition to be used against `UserNotification` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input UserNotificationCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `isRead` field."""
  isRead: Boolean

  """Checks for equality with the object’s `notificationType` field."""
  notificationType: NotificationType

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `message` field."""
  message: String

  """Checks for equality with the object’s `entityId` field."""
  entityId: UUID

  """Checks for equality with the object’s `entityImage` field."""
  entityImage: String
}

"""
A filter to be used against `UserNotification` object types. All fields are combined with a logical ‘and.’
"""
input UserNotificationFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Filter by the object’s `isRead` field."""
  isRead: BooleanFilter

  """Filter by the object’s `notificationType` field."""
  notificationType: NotificationTypeFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `message` field."""
  message: StringFilter

  """Filter by the object’s `entityId` field."""
  entityId: UUIDFilter

  """Filter by the object’s `entityImage` field."""
  entityImage: StringFilter

  """Checks for all expressions in this list."""
  and: [UserNotificationFilter!]

  """Checks for any expressions in this list."""
  or: [UserNotificationFilter!]

  """Negates the expression."""
  not: UserNotificationFilter
}

"""
A filter to be used against NotificationType fields. All fields are combined with a logical ‘and.’
"""
input NotificationTypeFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: NotificationType

  """Not equal to the specified value."""
  notEqualTo: NotificationType

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: NotificationType

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: NotificationType

  """Included in the specified list."""
  in: [NotificationType!]

  """Not included in the specified list."""
  notIn: [NotificationType!]

  """Less than the specified value."""
  lessThan: NotificationType

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: NotificationType

  """Greater than the specified value."""
  greaterThan: NotificationType

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: NotificationType
}

"""Methods to use when ordering `UserAnimeList`."""
enum UserAnimeListsOrderBy {
  NATURAL
  ANIME_LIST_ID_ASC
  ANIME_LIST_ID_DESC
  ANIME_ID_ASC
  ANIME_ID_DESC
  ANIME_INDEX_ASC
  ANIME_INDEX_DESC
  ANIME_LIST_BY_ANIME_LIST_ID__ID_ASC
  ANIME_LIST_BY_ANIME_LIST_ID__ID_DESC
  ANIME_LIST_BY_ANIME_LIST_ID__USER_ID_ASC
  ANIME_LIST_BY_ANIME_LIST_ID__USER_ID_DESC
  ANIME_LIST_BY_ANIME_LIST_ID__TITLE_ASC
  ANIME_LIST_BY_ANIME_LIST_ID__TITLE_DESC
  ANIME_LIST_BY_ANIME_LIST_ID__PRIVACY_ASC
  ANIME_LIST_BY_ANIME_LIST_ID__PRIVACY_DESC
  ANIME_LIST_BY_ANIME_LIST_ID__IS_DEFAULT_ASC
  ANIME_LIST_BY_ANIME_LIST_ID__IS_DEFAULT_DESC
  ANIME_LIST_BY_ANIME_LIST_ID__CREATED_AT_ASC
  ANIME_LIST_BY_ANIME_LIST_ID__CREATED_AT_DESC
  ANIME_BY_ANIME_ID__ID_ASC
  ANIME_BY_ANIME_ID__ID_DESC
  ANIME_BY_ANIME_ID__MAL_ID_ASC
  ANIME_BY_ANIME_ID__MAL_ID_DESC
  ANIME_BY_ANIME_ID__TITLE_ASC
  ANIME_BY_ANIME_ID__TITLE_DESC
  ANIME_BY_ANIME_ID__DESCRIPTION_ASC
  ANIME_BY_ANIME_ID__DESCRIPTION_DESC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_ASC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_DESC
  ANIME_BY_ANIME_ID__DURATION_ASC
  ANIME_BY_ANIME_ID__DURATION_DESC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_ASC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_DESC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_ASC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_DESC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_ASC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_DESC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_ASC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_DESC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_ASC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_DESC
  ANIME_BY_ANIME_ID__COVER_IMAGE_ASC
  ANIME_BY_ANIME_ID__COVER_IMAGE_DESC
  ANIME_BY_ANIME_ID__SEASON_ASC
  ANIME_BY_ANIME_ID__SEASON_DESC
  ANIME_BY_ANIME_ID__SEASON_YEAR_ASC
  ANIME_BY_ANIME_ID__SEASON_YEAR_DESC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_ASC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_DESC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_ASC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_DESC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_ASC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_DESC
}

"""
A condition to be used against `UserAnimeList` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input UserAnimeListCondition {
  """Checks for equality with the object’s `animeListId` field."""
  animeListId: UUID

  """Checks for equality with the object’s `animeId` field."""
  animeId: UUID

  """Checks for equality with the object’s `animeIndex` field."""
  animeIndex: String
}

"""
A filter to be used against `UserAnimeList` object types. All fields are combined with a logical ‘and.’
"""
input UserAnimeListFilter {
  """Filter by the object’s `animeListId` field."""
  animeListId: UUIDFilter

  """Filter by the object’s `animeId` field."""
  animeId: UUIDFilter

  """Filter by the object’s `animeIndex` field."""
  animeIndex: StringFilter

  """Checks for all expressions in this list."""
  and: [UserAnimeListFilter!]

  """Checks for any expressions in this list."""
  or: [UserAnimeListFilter!]

  """Negates the expression."""
  not: UserAnimeListFilter
}

"""A `UserAnimeList` edge in the connection."""
type UserAnimeListsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserAnimeList` at the end of the edge."""
  node: UserAnimeList!
}

"""Methods to use when ordering `AlternateAnimeName`."""
enum AlternateAnimeNamesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ANIME_ID_ASC
  ANIME_ID_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_BY_ANIME_ID__ID_ASC
  ANIME_BY_ANIME_ID__ID_DESC
  ANIME_BY_ANIME_ID__MAL_ID_ASC
  ANIME_BY_ANIME_ID__MAL_ID_DESC
  ANIME_BY_ANIME_ID__TITLE_ASC
  ANIME_BY_ANIME_ID__TITLE_DESC
  ANIME_BY_ANIME_ID__DESCRIPTION_ASC
  ANIME_BY_ANIME_ID__DESCRIPTION_DESC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_ASC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_DESC
  ANIME_BY_ANIME_ID__DURATION_ASC
  ANIME_BY_ANIME_ID__DURATION_DESC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_ASC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_DESC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_ASC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_DESC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_ASC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_DESC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_ASC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_DESC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_ASC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_DESC
  ANIME_BY_ANIME_ID__COVER_IMAGE_ASC
  ANIME_BY_ANIME_ID__COVER_IMAGE_DESC
  ANIME_BY_ANIME_ID__SEASON_ASC
  ANIME_BY_ANIME_ID__SEASON_DESC
  ANIME_BY_ANIME_ID__SEASON_YEAR_ASC
  ANIME_BY_ANIME_ID__SEASON_YEAR_DESC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_ASC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_DESC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_ASC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_DESC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_ASC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_DESC
}

"""
A condition to be used against `AlternateAnimeName` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input AlternateAnimeNameCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `animeId` field."""
  animeId: UUID

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""
A filter to be used against `AlternateAnimeName` object types. All fields are combined with a logical ‘and.’
"""
input AlternateAnimeNameFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `animeId` field."""
  animeId: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Checks for all expressions in this list."""
  and: [AlternateAnimeNameFilter!]

  """Checks for any expressions in this list."""
  or: [AlternateAnimeNameFilter!]

  """Negates the expression."""
  not: AlternateAnimeNameFilter
}

"""A connection to a list of `AnimeCharacter` values."""
type AnimeCharactersConnection {
  """A list of `AnimeCharacter` objects."""
  nodes: [AnimeCharacter!]!

  """
  A list of edges which contains the `AnimeCharacter` and cursor to aid in pagination.
  """
  edges: [AnimeCharactersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AnimeCharacter` you could get from the connection."""
  totalCount: Int!
}

type AnimeCharacter implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  animeId: UUID!
  characterId: UUID!
  personId: UUID!
  characterRoleId: UUID!
  language: LanguageType!

  """Reads a single `Anime` that is related to this `AnimeCharacter`."""
  anime: Anime

  """Reads a single `Character` that is related to this `AnimeCharacter`."""
  character: Character

  """Reads a single `Person` that is related to this `AnimeCharacter`."""
  person: Person

  """
  Reads a single `CharacterRole` that is related to this `AnimeCharacter`.
  """
  characterRole: CharacterRole
}

enum LanguageType {
  JAPANESE
  ENGLISH
  PORTUGUESE_BR_
  ITALIAN
  SPANISH
  GERMAN
  KOREAN
  FRENCH
  MANDARIN
}

type Character implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  malId: String
  name: String!
  description: String

  """Reads a single `Image` that is related to this `Character`."""
  characterImage: Image

  """Reads and enables pagination through a set of `AnimeCharacter`."""
  animeCharacters(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeCharacter`."""
    orderBy: [AnimeCharactersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeCharacterCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeCharacterFilter
  ): AnimeCharactersConnection!

  """Reads and enables pagination through a set of `CharacterImage`."""
  characterImages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CharacterImage`."""
    orderBy: [CharacterImagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CharacterImageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CharacterImageFilter
  ): CharacterImagesConnection!
}

type Image implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  title: String!
  url: String!

  """Reads and enables pagination through a set of `AnimeImage`."""
  animeImages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeImage`."""
    orderBy: [AnimeImagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeImageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeImageFilter
  ): AnimeImagesConnection!

  """Reads and enables pagination through a set of `CharacterImage`."""
  characterImages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CharacterImage`."""
    orderBy: [CharacterImagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CharacterImageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CharacterImageFilter
  ): CharacterImagesConnection!

  """Reads and enables pagination through a set of `Character`."""
  charactersByCharacterImageId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Character`."""
    orderBy: [CharactersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CharacterCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CharacterFilter
  ): CharactersConnection!

  """Reads and enables pagination through a set of `PersonImage`."""
  personImages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PersonImage`."""
    orderBy: [PersonImagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PersonImageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PersonImageFilter
  ): PersonImagesConnection!

  """Reads and enables pagination through a set of `Person`."""
  peopleByPersonImageId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Person`."""
    orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PersonCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PersonFilter
  ): PeopleConnection!
}

"""A connection to a list of `AnimeImage` values."""
type AnimeImagesConnection {
  """A list of `AnimeImage` objects."""
  nodes: [AnimeImage!]!

  """
  A list of edges which contains the `AnimeImage` and cursor to aid in pagination.
  """
  edges: [AnimeImagesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AnimeImage` you could get from the connection."""
  totalCount: Int!
}

type AnimeImage implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  animeId: UUID!
  imageId: UUID!

  """Reads a single `Anime` that is related to this `AnimeImage`."""
  anime: Anime

  """Reads a single `Image` that is related to this `AnimeImage`."""
  image: Image
}

"""A `AnimeImage` edge in the connection."""
type AnimeImagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AnimeImage` at the end of the edge."""
  node: AnimeImage!
}

"""Methods to use when ordering `AnimeImage`."""
enum AnimeImagesOrderBy {
  NATURAL
  ANIME_ID_ASC
  ANIME_ID_DESC
  IMAGE_ID_ASC
  IMAGE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_BY_ANIME_ID__ID_ASC
  ANIME_BY_ANIME_ID__ID_DESC
  ANIME_BY_ANIME_ID__MAL_ID_ASC
  ANIME_BY_ANIME_ID__MAL_ID_DESC
  ANIME_BY_ANIME_ID__TITLE_ASC
  ANIME_BY_ANIME_ID__TITLE_DESC
  ANIME_BY_ANIME_ID__DESCRIPTION_ASC
  ANIME_BY_ANIME_ID__DESCRIPTION_DESC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_ASC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_DESC
  ANIME_BY_ANIME_ID__DURATION_ASC
  ANIME_BY_ANIME_ID__DURATION_DESC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_ASC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_DESC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_ASC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_DESC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_ASC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_DESC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_ASC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_DESC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_ASC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_DESC
  ANIME_BY_ANIME_ID__COVER_IMAGE_ASC
  ANIME_BY_ANIME_ID__COVER_IMAGE_DESC
  ANIME_BY_ANIME_ID__SEASON_ASC
  ANIME_BY_ANIME_ID__SEASON_DESC
  ANIME_BY_ANIME_ID__SEASON_YEAR_ASC
  ANIME_BY_ANIME_ID__SEASON_YEAR_DESC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_ASC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_DESC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_ASC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_DESC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_ASC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_DESC
  IMAGE_BY_IMAGE_ID__ID_ASC
  IMAGE_BY_IMAGE_ID__ID_DESC
  IMAGE_BY_IMAGE_ID__TITLE_ASC
  IMAGE_BY_IMAGE_ID__TITLE_DESC
  IMAGE_BY_IMAGE_ID__URL_ASC
  IMAGE_BY_IMAGE_ID__URL_DESC
}

"""
A condition to be used against `AnimeImage` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input AnimeImageCondition {
  """Checks for equality with the object’s `animeId` field."""
  animeId: UUID

  """Checks for equality with the object’s `imageId` field."""
  imageId: UUID
}

"""
A filter to be used against `AnimeImage` object types. All fields are combined with a logical ‘and.’
"""
input AnimeImageFilter {
  """Filter by the object’s `animeId` field."""
  animeId: UUIDFilter

  """Filter by the object’s `imageId` field."""
  imageId: UUIDFilter

  """Checks for all expressions in this list."""
  and: [AnimeImageFilter!]

  """Checks for any expressions in this list."""
  or: [AnimeImageFilter!]

  """Negates the expression."""
  not: AnimeImageFilter
}

"""A connection to a list of `CharacterImage` values."""
type CharacterImagesConnection {
  """A list of `CharacterImage` objects."""
  nodes: [CharacterImage!]!

  """
  A list of edges which contains the `CharacterImage` and cursor to aid in pagination.
  """
  edges: [CharacterImagesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `CharacterImage` you could get from the connection."""
  totalCount: Int!
}

type CharacterImage implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  characterId: UUID!
  imageId: UUID!

  """Reads a single `Character` that is related to this `CharacterImage`."""
  character: Character

  """Reads a single `Image` that is related to this `CharacterImage`."""
  image: Image
}

"""A `CharacterImage` edge in the connection."""
type CharacterImagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CharacterImage` at the end of the edge."""
  node: CharacterImage!
}

"""Methods to use when ordering `CharacterImage`."""
enum CharacterImagesOrderBy {
  NATURAL
  CHARACTER_ID_ASC
  CHARACTER_ID_DESC
  IMAGE_ID_ASC
  IMAGE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  CHARACTER_BY_CHARACTER_ID__ID_ASC
  CHARACTER_BY_CHARACTER_ID__ID_DESC
  CHARACTER_BY_CHARACTER_ID__MAL_ID_ASC
  CHARACTER_BY_CHARACTER_ID__MAL_ID_DESC
  CHARACTER_BY_CHARACTER_ID__NAME_ASC
  CHARACTER_BY_CHARACTER_ID__NAME_DESC
  CHARACTER_BY_CHARACTER_ID__DESCRIPTION_ASC
  CHARACTER_BY_CHARACTER_ID__DESCRIPTION_DESC
  CHARACTER_BY_CHARACTER_ID__CHARACTER_IMAGE_ID_ASC
  CHARACTER_BY_CHARACTER_ID__CHARACTER_IMAGE_ID_DESC
  IMAGE_BY_IMAGE_ID__ID_ASC
  IMAGE_BY_IMAGE_ID__ID_DESC
  IMAGE_BY_IMAGE_ID__TITLE_ASC
  IMAGE_BY_IMAGE_ID__TITLE_DESC
  IMAGE_BY_IMAGE_ID__URL_ASC
  IMAGE_BY_IMAGE_ID__URL_DESC
}

"""
A condition to be used against `CharacterImage` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CharacterImageCondition {
  """Checks for equality with the object’s `characterId` field."""
  characterId: UUID

  """Checks for equality with the object’s `imageId` field."""
  imageId: UUID
}

"""
A filter to be used against `CharacterImage` object types. All fields are combined with a logical ‘and.’
"""
input CharacterImageFilter {
  """Filter by the object’s `characterId` field."""
  characterId: UUIDFilter

  """Filter by the object’s `imageId` field."""
  imageId: UUIDFilter

  """Checks for all expressions in this list."""
  and: [CharacterImageFilter!]

  """Checks for any expressions in this list."""
  or: [CharacterImageFilter!]

  """Negates the expression."""
  not: CharacterImageFilter
}

"""A connection to a list of `Character` values."""
type CharactersConnection {
  """A list of `Character` objects."""
  nodes: [Character!]!

  """
  A list of edges which contains the `Character` and cursor to aid in pagination.
  """
  edges: [CharactersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Character` you could get from the connection."""
  totalCount: Int!
}

"""A `Character` edge in the connection."""
type CharactersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Character` at the end of the edge."""
  node: Character!
}

"""Methods to use when ordering `Character`."""
enum CharactersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MAL_ID_ASC
  MAL_ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CHARACTER_IMAGE_ID_ASC
  CHARACTER_IMAGE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  IMAGE_BY_CHARACTER_IMAGE_ID__ID_ASC
  IMAGE_BY_CHARACTER_IMAGE_ID__ID_DESC
  IMAGE_BY_CHARACTER_IMAGE_ID__TITLE_ASC
  IMAGE_BY_CHARACTER_IMAGE_ID__TITLE_DESC
  IMAGE_BY_CHARACTER_IMAGE_ID__URL_ASC
  IMAGE_BY_CHARACTER_IMAGE_ID__URL_DESC
  ANIME_CHARACTERS_BY_CHARACTER_ID__COUNT_ASC
  ANIME_CHARACTERS_BY_CHARACTER_ID__COUNT_DESC
  CHARACTER_IMAGES_BY_CHARACTER_ID__COUNT_ASC
  CHARACTER_IMAGES_BY_CHARACTER_ID__COUNT_DESC
}

"""
A condition to be used against `Character` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CharacterCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `malId` field."""
  malId: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `characterImageId` field."""
  characterImageId: UUID
}

"""
A filter to be used against `Character` object types. All fields are combined with a logical ‘and.’
"""
input CharacterFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `malId` field."""
  malId: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Filter by the object’s `description` field."""
  description: StringFilter

  """Filter by the object’s `characterImageId` field."""
  characterImageId: UUIDFilter

  """Checks for all expressions in this list."""
  and: [CharacterFilter!]

  """Checks for any expressions in this list."""
  or: [CharacterFilter!]

  """Negates the expression."""
  not: CharacterFilter
}

"""A connection to a list of `PersonImage` values."""
type PersonImagesConnection {
  """A list of `PersonImage` objects."""
  nodes: [PersonImage!]!

  """
  A list of edges which contains the `PersonImage` and cursor to aid in pagination.
  """
  edges: [PersonImagesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `PersonImage` you could get from the connection."""
  totalCount: Int!
}

type PersonImage implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  personId: UUID!
  imageId: UUID!

  """Reads a single `Person` that is related to this `PersonImage`."""
  person: Person

  """Reads a single `Image` that is related to this `PersonImage`."""
  image: Image
}

type Person implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  malId: String
  firstName: String!
  lastName: String
  nativeName: String
  alternateNames: String
  description: String

  """Reads a single `Image` that is related to this `Person`."""
  personImage: Image

  """Reads and enables pagination through a set of `AnimeCharacter`."""
  animeCharacters(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeCharacter`."""
    orderBy: [AnimeCharactersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeCharacterCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeCharacterFilter
  ): AnimeCharactersConnection!

  """Reads and enables pagination through a set of `AnimeStaff`."""
  animeStaffs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeStaff`."""
    orderBy: [AnimeStaffOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeStaffCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeStaffFilter
  ): AnimeStaffConnection!

  """Reads and enables pagination through a set of `PersonImage`."""
  personImages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PersonImage`."""
    orderBy: [PersonImagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PersonImageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PersonImageFilter
  ): PersonImagesConnection!
}

"""Methods to use when ordering `AnimeCharacter`."""
enum AnimeCharactersOrderBy {
  NATURAL
  ANIME_ID_ASC
  ANIME_ID_DESC
  CHARACTER_ID_ASC
  CHARACTER_ID_DESC
  PERSON_ID_ASC
  PERSON_ID_DESC
  CHARACTER_ROLE_ID_ASC
  CHARACTER_ROLE_ID_DESC
  LANGUAGE_ASC
  LANGUAGE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_BY_ANIME_ID__ID_ASC
  ANIME_BY_ANIME_ID__ID_DESC
  ANIME_BY_ANIME_ID__MAL_ID_ASC
  ANIME_BY_ANIME_ID__MAL_ID_DESC
  ANIME_BY_ANIME_ID__TITLE_ASC
  ANIME_BY_ANIME_ID__TITLE_DESC
  ANIME_BY_ANIME_ID__DESCRIPTION_ASC
  ANIME_BY_ANIME_ID__DESCRIPTION_DESC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_ASC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_DESC
  ANIME_BY_ANIME_ID__DURATION_ASC
  ANIME_BY_ANIME_ID__DURATION_DESC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_ASC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_DESC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_ASC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_DESC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_ASC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_DESC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_ASC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_DESC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_ASC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_DESC
  ANIME_BY_ANIME_ID__COVER_IMAGE_ASC
  ANIME_BY_ANIME_ID__COVER_IMAGE_DESC
  ANIME_BY_ANIME_ID__SEASON_ASC
  ANIME_BY_ANIME_ID__SEASON_DESC
  ANIME_BY_ANIME_ID__SEASON_YEAR_ASC
  ANIME_BY_ANIME_ID__SEASON_YEAR_DESC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_ASC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_DESC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_ASC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_DESC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_ASC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_DESC
  CHARACTER_BY_CHARACTER_ID__ID_ASC
  CHARACTER_BY_CHARACTER_ID__ID_DESC
  CHARACTER_BY_CHARACTER_ID__MAL_ID_ASC
  CHARACTER_BY_CHARACTER_ID__MAL_ID_DESC
  CHARACTER_BY_CHARACTER_ID__NAME_ASC
  CHARACTER_BY_CHARACTER_ID__NAME_DESC
  CHARACTER_BY_CHARACTER_ID__DESCRIPTION_ASC
  CHARACTER_BY_CHARACTER_ID__DESCRIPTION_DESC
  CHARACTER_BY_CHARACTER_ID__CHARACTER_IMAGE_ID_ASC
  CHARACTER_BY_CHARACTER_ID__CHARACTER_IMAGE_ID_DESC
  PERSON_BY_PERSON_ID__ID_ASC
  PERSON_BY_PERSON_ID__ID_DESC
  PERSON_BY_PERSON_ID__MAL_ID_ASC
  PERSON_BY_PERSON_ID__MAL_ID_DESC
  PERSON_BY_PERSON_ID__FIRST_NAME_ASC
  PERSON_BY_PERSON_ID__FIRST_NAME_DESC
  PERSON_BY_PERSON_ID__LAST_NAME_ASC
  PERSON_BY_PERSON_ID__LAST_NAME_DESC
  PERSON_BY_PERSON_ID__NATIVE_NAME_ASC
  PERSON_BY_PERSON_ID__NATIVE_NAME_DESC
  PERSON_BY_PERSON_ID__ALTERNATE_NAMES_ASC
  PERSON_BY_PERSON_ID__ALTERNATE_NAMES_DESC
  PERSON_BY_PERSON_ID__DESCRIPTION_ASC
  PERSON_BY_PERSON_ID__DESCRIPTION_DESC
  PERSON_BY_PERSON_ID__PERSON_IMAGE_ID_ASC
  PERSON_BY_PERSON_ID__PERSON_IMAGE_ID_DESC
  CHARACTER_ROLE_BY_CHARACTER_ROLE_ID__ID_ASC
  CHARACTER_ROLE_BY_CHARACTER_ROLE_ID__ID_DESC
  CHARACTER_ROLE_BY_CHARACTER_ROLE_ID__ROLE_ASC
  CHARACTER_ROLE_BY_CHARACTER_ROLE_ID__ROLE_DESC
}

"""
A condition to be used against `AnimeCharacter` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input AnimeCharacterCondition {
  """Checks for equality with the object’s `animeId` field."""
  animeId: UUID

  """Checks for equality with the object’s `characterId` field."""
  characterId: UUID

  """Checks for equality with the object’s `personId` field."""
  personId: UUID

  """Checks for equality with the object’s `characterRoleId` field."""
  characterRoleId: UUID

  """Checks for equality with the object’s `language` field."""
  language: LanguageType
}

"""
A filter to be used against `AnimeCharacter` object types. All fields are combined with a logical ‘and.’
"""
input AnimeCharacterFilter {
  """Filter by the object’s `animeId` field."""
  animeId: UUIDFilter

  """Filter by the object’s `characterId` field."""
  characterId: UUIDFilter

  """Filter by the object’s `personId` field."""
  personId: UUIDFilter

  """Filter by the object’s `characterRoleId` field."""
  characterRoleId: UUIDFilter

  """Filter by the object’s `language` field."""
  language: LanguageTypeFilter

  """Checks for all expressions in this list."""
  and: [AnimeCharacterFilter!]

  """Checks for any expressions in this list."""
  or: [AnimeCharacterFilter!]

  """Negates the expression."""
  not: AnimeCharacterFilter
}

"""
A filter to be used against LanguageType fields. All fields are combined with a logical ‘and.’
"""
input LanguageTypeFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: LanguageType

  """Not equal to the specified value."""
  notEqualTo: LanguageType

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: LanguageType

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: LanguageType

  """Included in the specified list."""
  in: [LanguageType!]

  """Not included in the specified list."""
  notIn: [LanguageType!]

  """Less than the specified value."""
  lessThan: LanguageType

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: LanguageType

  """Greater than the specified value."""
  greaterThan: LanguageType

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: LanguageType
}

"""A connection to a list of `AnimeStaff` values."""
type AnimeStaffConnection {
  """A list of `AnimeStaff` objects."""
  nodes: [AnimeStaff!]!

  """
  A list of edges which contains the `AnimeStaff` and cursor to aid in pagination.
  """
  edges: [AnimeStaffEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AnimeStaff` you could get from the connection."""
  totalCount: Int!
}

type AnimeStaff implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  animeId: UUID!
  personId: UUID!
  staffRoleId: UUID!

  """Reads a single `Anime` that is related to this `AnimeStaff`."""
  anime: Anime

  """Reads a single `Person` that is related to this `AnimeStaff`."""
  person: Person

  """Reads a single `StaffRole` that is related to this `AnimeStaff`."""
  staffRole: StaffRole
}

type StaffRole implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  role: String!

  """Reads and enables pagination through a set of `AnimeStaff`."""
  animeStaffs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeStaff`."""
    orderBy: [AnimeStaffOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeStaffCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeStaffFilter
  ): AnimeStaffConnection!
}

"""Methods to use when ordering `AnimeStaff`."""
enum AnimeStaffOrderBy {
  NATURAL
  ANIME_ID_ASC
  ANIME_ID_DESC
  PERSON_ID_ASC
  PERSON_ID_DESC
  STAFF_ROLE_ID_ASC
  STAFF_ROLE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_BY_ANIME_ID__ID_ASC
  ANIME_BY_ANIME_ID__ID_DESC
  ANIME_BY_ANIME_ID__MAL_ID_ASC
  ANIME_BY_ANIME_ID__MAL_ID_DESC
  ANIME_BY_ANIME_ID__TITLE_ASC
  ANIME_BY_ANIME_ID__TITLE_DESC
  ANIME_BY_ANIME_ID__DESCRIPTION_ASC
  ANIME_BY_ANIME_ID__DESCRIPTION_DESC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_ASC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_DESC
  ANIME_BY_ANIME_ID__DURATION_ASC
  ANIME_BY_ANIME_ID__DURATION_DESC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_ASC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_DESC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_ASC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_DESC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_ASC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_DESC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_ASC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_DESC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_ASC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_DESC
  ANIME_BY_ANIME_ID__COVER_IMAGE_ASC
  ANIME_BY_ANIME_ID__COVER_IMAGE_DESC
  ANIME_BY_ANIME_ID__SEASON_ASC
  ANIME_BY_ANIME_ID__SEASON_DESC
  ANIME_BY_ANIME_ID__SEASON_YEAR_ASC
  ANIME_BY_ANIME_ID__SEASON_YEAR_DESC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_ASC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_DESC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_ASC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_DESC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_ASC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_DESC
  PERSON_BY_PERSON_ID__ID_ASC
  PERSON_BY_PERSON_ID__ID_DESC
  PERSON_BY_PERSON_ID__MAL_ID_ASC
  PERSON_BY_PERSON_ID__MAL_ID_DESC
  PERSON_BY_PERSON_ID__FIRST_NAME_ASC
  PERSON_BY_PERSON_ID__FIRST_NAME_DESC
  PERSON_BY_PERSON_ID__LAST_NAME_ASC
  PERSON_BY_PERSON_ID__LAST_NAME_DESC
  PERSON_BY_PERSON_ID__NATIVE_NAME_ASC
  PERSON_BY_PERSON_ID__NATIVE_NAME_DESC
  PERSON_BY_PERSON_ID__ALTERNATE_NAMES_ASC
  PERSON_BY_PERSON_ID__ALTERNATE_NAMES_DESC
  PERSON_BY_PERSON_ID__DESCRIPTION_ASC
  PERSON_BY_PERSON_ID__DESCRIPTION_DESC
  PERSON_BY_PERSON_ID__PERSON_IMAGE_ID_ASC
  PERSON_BY_PERSON_ID__PERSON_IMAGE_ID_DESC
  STAFF_ROLE_BY_STAFF_ROLE_ID__ID_ASC
  STAFF_ROLE_BY_STAFF_ROLE_ID__ID_DESC
  STAFF_ROLE_BY_STAFF_ROLE_ID__ROLE_ASC
  STAFF_ROLE_BY_STAFF_ROLE_ID__ROLE_DESC
}

"""
A condition to be used against `AnimeStaff` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input AnimeStaffCondition {
  """Checks for equality with the object’s `animeId` field."""
  animeId: UUID

  """Checks for equality with the object’s `personId` field."""
  personId: UUID

  """Checks for equality with the object’s `staffRoleId` field."""
  staffRoleId: UUID
}

"""
A filter to be used against `AnimeStaff` object types. All fields are combined with a logical ‘and.’
"""
input AnimeStaffFilter {
  """Filter by the object’s `animeId` field."""
  animeId: UUIDFilter

  """Filter by the object’s `personId` field."""
  personId: UUIDFilter

  """Filter by the object’s `staffRoleId` field."""
  staffRoleId: UUIDFilter

  """Checks for all expressions in this list."""
  and: [AnimeStaffFilter!]

  """Checks for any expressions in this list."""
  or: [AnimeStaffFilter!]

  """Negates the expression."""
  not: AnimeStaffFilter
}

"""A `AnimeStaff` edge in the connection."""
type AnimeStaffEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AnimeStaff` at the end of the edge."""
  node: AnimeStaff!
}

"""Methods to use when ordering `PersonImage`."""
enum PersonImagesOrderBy {
  NATURAL
  PERSON_ID_ASC
  PERSON_ID_DESC
  IMAGE_ID_ASC
  IMAGE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PERSON_BY_PERSON_ID__ID_ASC
  PERSON_BY_PERSON_ID__ID_DESC
  PERSON_BY_PERSON_ID__MAL_ID_ASC
  PERSON_BY_PERSON_ID__MAL_ID_DESC
  PERSON_BY_PERSON_ID__FIRST_NAME_ASC
  PERSON_BY_PERSON_ID__FIRST_NAME_DESC
  PERSON_BY_PERSON_ID__LAST_NAME_ASC
  PERSON_BY_PERSON_ID__LAST_NAME_DESC
  PERSON_BY_PERSON_ID__NATIVE_NAME_ASC
  PERSON_BY_PERSON_ID__NATIVE_NAME_DESC
  PERSON_BY_PERSON_ID__ALTERNATE_NAMES_ASC
  PERSON_BY_PERSON_ID__ALTERNATE_NAMES_DESC
  PERSON_BY_PERSON_ID__DESCRIPTION_ASC
  PERSON_BY_PERSON_ID__DESCRIPTION_DESC
  PERSON_BY_PERSON_ID__PERSON_IMAGE_ID_ASC
  PERSON_BY_PERSON_ID__PERSON_IMAGE_ID_DESC
  IMAGE_BY_IMAGE_ID__ID_ASC
  IMAGE_BY_IMAGE_ID__ID_DESC
  IMAGE_BY_IMAGE_ID__TITLE_ASC
  IMAGE_BY_IMAGE_ID__TITLE_DESC
  IMAGE_BY_IMAGE_ID__URL_ASC
  IMAGE_BY_IMAGE_ID__URL_DESC
}

"""
A condition to be used against `PersonImage` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input PersonImageCondition {
  """Checks for equality with the object’s `personId` field."""
  personId: UUID

  """Checks for equality with the object’s `imageId` field."""
  imageId: UUID
}

"""
A filter to be used against `PersonImage` object types. All fields are combined with a logical ‘and.’
"""
input PersonImageFilter {
  """Filter by the object’s `personId` field."""
  personId: UUIDFilter

  """Filter by the object’s `imageId` field."""
  imageId: UUIDFilter

  """Checks for all expressions in this list."""
  and: [PersonImageFilter!]

  """Checks for any expressions in this list."""
  or: [PersonImageFilter!]

  """Negates the expression."""
  not: PersonImageFilter
}

"""A `PersonImage` edge in the connection."""
type PersonImagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PersonImage` at the end of the edge."""
  node: PersonImage!
}

"""A connection to a list of `Person` values."""
type PeopleConnection {
  """A list of `Person` objects."""
  nodes: [Person!]!

  """
  A list of edges which contains the `Person` and cursor to aid in pagination.
  """
  edges: [PeopleEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Person` you could get from the connection."""
  totalCount: Int!
}

"""A `Person` edge in the connection."""
type PeopleEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Person` at the end of the edge."""
  node: Person!
}

"""Methods to use when ordering `Person`."""
enum PeopleOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MAL_ID_ASC
  MAL_ID_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  NATIVE_NAME_ASC
  NATIVE_NAME_DESC
  ALTERNATE_NAMES_ASC
  ALTERNATE_NAMES_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PERSON_IMAGE_ID_ASC
  PERSON_IMAGE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  IMAGE_BY_PERSON_IMAGE_ID__ID_ASC
  IMAGE_BY_PERSON_IMAGE_ID__ID_DESC
  IMAGE_BY_PERSON_IMAGE_ID__TITLE_ASC
  IMAGE_BY_PERSON_IMAGE_ID__TITLE_DESC
  IMAGE_BY_PERSON_IMAGE_ID__URL_ASC
  IMAGE_BY_PERSON_IMAGE_ID__URL_DESC
  ANIME_CHARACTERS_BY_PERSON_ID__COUNT_ASC
  ANIME_CHARACTERS_BY_PERSON_ID__COUNT_DESC
  ANIME_STAFF_BY_PERSON_ID__COUNT_ASC
  ANIME_STAFF_BY_PERSON_ID__COUNT_DESC
  PERSON_IMAGES_BY_PERSON_ID__COUNT_ASC
  PERSON_IMAGES_BY_PERSON_ID__COUNT_DESC
}

"""
A condition to be used against `Person` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PersonCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `malId` field."""
  malId: String

  """Checks for equality with the object’s `firstName` field."""
  firstName: String

  """Checks for equality with the object’s `lastName` field."""
  lastName: String

  """Checks for equality with the object’s `nativeName` field."""
  nativeName: String

  """Checks for equality with the object’s `alternateNames` field."""
  alternateNames: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `personImageId` field."""
  personImageId: UUID
}

"""
A filter to be used against `Person` object types. All fields are combined with a logical ‘and.’
"""
input PersonFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `malId` field."""
  malId: StringFilter

  """Filter by the object’s `firstName` field."""
  firstName: StringFilter

  """Filter by the object’s `lastName` field."""
  lastName: StringFilter

  """Filter by the object’s `nativeName` field."""
  nativeName: StringFilter

  """Filter by the object’s `alternateNames` field."""
  alternateNames: StringFilter

  """Filter by the object’s `description` field."""
  description: StringFilter

  """Filter by the object’s `personImageId` field."""
  personImageId: UUIDFilter

  """Checks for all expressions in this list."""
  and: [PersonFilter!]

  """Checks for any expressions in this list."""
  or: [PersonFilter!]

  """Negates the expression."""
  not: PersonFilter
}

type CharacterRole implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  role: String!

  """Reads and enables pagination through a set of `AnimeCharacter`."""
  animeCharacters(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeCharacter`."""
    orderBy: [AnimeCharactersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeCharacterCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeCharacterFilter
  ): AnimeCharactersConnection!
}

"""A `AnimeCharacter` edge in the connection."""
type AnimeCharactersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AnimeCharacter` at the end of the edge."""
  node: AnimeCharacter!
}

"""A connection to a list of `AnimeGenre` values."""
type AnimeGenresConnection {
  """A list of `AnimeGenre` objects."""
  nodes: [AnimeGenre!]!

  """
  A list of edges which contains the `AnimeGenre` and cursor to aid in pagination.
  """
  edges: [AnimeGenresEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AnimeGenre` you could get from the connection."""
  totalCount: Int!
}

type AnimeGenre implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  animeId: UUID!
  genreId: UUID!

  """Reads a single `Anime` that is related to this `AnimeGenre`."""
  anime: Anime

  """Reads a single `Genre` that is related to this `AnimeGenre`."""
  genre: Genre
}

type Genre implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  genre: String!

  """Reads and enables pagination through a set of `AnimeGenre`."""
  animeGenres(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeGenre`."""
    orderBy: [AnimeGenresOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeGenreCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeGenreFilter
  ): AnimeGenresConnection!
}

"""Methods to use when ordering `AnimeGenre`."""
enum AnimeGenresOrderBy {
  NATURAL
  ANIME_ID_ASC
  ANIME_ID_DESC
  GENRE_ID_ASC
  GENRE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_BY_ANIME_ID__ID_ASC
  ANIME_BY_ANIME_ID__ID_DESC
  ANIME_BY_ANIME_ID__MAL_ID_ASC
  ANIME_BY_ANIME_ID__MAL_ID_DESC
  ANIME_BY_ANIME_ID__TITLE_ASC
  ANIME_BY_ANIME_ID__TITLE_DESC
  ANIME_BY_ANIME_ID__DESCRIPTION_ASC
  ANIME_BY_ANIME_ID__DESCRIPTION_DESC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_ASC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_DESC
  ANIME_BY_ANIME_ID__DURATION_ASC
  ANIME_BY_ANIME_ID__DURATION_DESC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_ASC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_DESC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_ASC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_DESC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_ASC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_DESC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_ASC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_DESC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_ASC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_DESC
  ANIME_BY_ANIME_ID__COVER_IMAGE_ASC
  ANIME_BY_ANIME_ID__COVER_IMAGE_DESC
  ANIME_BY_ANIME_ID__SEASON_ASC
  ANIME_BY_ANIME_ID__SEASON_DESC
  ANIME_BY_ANIME_ID__SEASON_YEAR_ASC
  ANIME_BY_ANIME_ID__SEASON_YEAR_DESC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_ASC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_DESC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_ASC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_DESC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_ASC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_DESC
  GENRE_BY_GENRE_ID__ID_ASC
  GENRE_BY_GENRE_ID__ID_DESC
  GENRE_BY_GENRE_ID__GENRE_ASC
  GENRE_BY_GENRE_ID__GENRE_DESC
}

"""
A condition to be used against `AnimeGenre` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input AnimeGenreCondition {
  """Checks for equality with the object’s `animeId` field."""
  animeId: UUID

  """Checks for equality with the object’s `genreId` field."""
  genreId: UUID
}

"""
A filter to be used against `AnimeGenre` object types. All fields are combined with a logical ‘and.’
"""
input AnimeGenreFilter {
  """Filter by the object’s `animeId` field."""
  animeId: UUIDFilter

  """Filter by the object’s `genreId` field."""
  genreId: UUIDFilter

  """Checks for all expressions in this list."""
  and: [AnimeGenreFilter!]

  """Checks for any expressions in this list."""
  or: [AnimeGenreFilter!]

  """Negates the expression."""
  not: AnimeGenreFilter
}

"""A `AnimeGenre` edge in the connection."""
type AnimeGenresEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AnimeGenre` at the end of the edge."""
  node: AnimeGenre!
}

"""A connection to a list of `AnimeLicensor` values."""
type AnimeLicensorsConnection {
  """A list of `AnimeLicensor` objects."""
  nodes: [AnimeLicensor!]!

  """
  A list of edges which contains the `AnimeLicensor` and cursor to aid in pagination.
  """
  edges: [AnimeLicensorsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AnimeLicensor` you could get from the connection."""
  totalCount: Int!
}

type AnimeLicensor implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  animeId: UUID!
  licensorId: UUID!

  """Reads a single `Anime` that is related to this `AnimeLicensor`."""
  anime: Anime

  """Reads a single `Licensor` that is related to this `AnimeLicensor`."""
  licensor: Licensor
}

type Licensor implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  licensor: String!

  """Reads and enables pagination through a set of `AnimeLicensor`."""
  animeLicensors(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeLicensor`."""
    orderBy: [AnimeLicensorsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeLicensorCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeLicensorFilter
  ): AnimeLicensorsConnection!
}

"""Methods to use when ordering `AnimeLicensor`."""
enum AnimeLicensorsOrderBy {
  NATURAL
  ANIME_ID_ASC
  ANIME_ID_DESC
  LICENSOR_ID_ASC
  LICENSOR_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_BY_ANIME_ID__ID_ASC
  ANIME_BY_ANIME_ID__ID_DESC
  ANIME_BY_ANIME_ID__MAL_ID_ASC
  ANIME_BY_ANIME_ID__MAL_ID_DESC
  ANIME_BY_ANIME_ID__TITLE_ASC
  ANIME_BY_ANIME_ID__TITLE_DESC
  ANIME_BY_ANIME_ID__DESCRIPTION_ASC
  ANIME_BY_ANIME_ID__DESCRIPTION_DESC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_ASC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_DESC
  ANIME_BY_ANIME_ID__DURATION_ASC
  ANIME_BY_ANIME_ID__DURATION_DESC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_ASC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_DESC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_ASC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_DESC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_ASC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_DESC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_ASC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_DESC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_ASC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_DESC
  ANIME_BY_ANIME_ID__COVER_IMAGE_ASC
  ANIME_BY_ANIME_ID__COVER_IMAGE_DESC
  ANIME_BY_ANIME_ID__SEASON_ASC
  ANIME_BY_ANIME_ID__SEASON_DESC
  ANIME_BY_ANIME_ID__SEASON_YEAR_ASC
  ANIME_BY_ANIME_ID__SEASON_YEAR_DESC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_ASC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_DESC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_ASC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_DESC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_ASC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_DESC
  LICENSOR_BY_LICENSOR_ID__ID_ASC
  LICENSOR_BY_LICENSOR_ID__ID_DESC
  LICENSOR_BY_LICENSOR_ID__LICENSOR_ASC
  LICENSOR_BY_LICENSOR_ID__LICENSOR_DESC
}

"""
A condition to be used against `AnimeLicensor` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input AnimeLicensorCondition {
  """Checks for equality with the object’s `animeId` field."""
  animeId: UUID

  """Checks for equality with the object’s `licensorId` field."""
  licensorId: UUID
}

"""
A filter to be used against `AnimeLicensor` object types. All fields are combined with a logical ‘and.’
"""
input AnimeLicensorFilter {
  """Filter by the object’s `animeId` field."""
  animeId: UUIDFilter

  """Filter by the object’s `licensorId` field."""
  licensorId: UUIDFilter

  """Checks for all expressions in this list."""
  and: [AnimeLicensorFilter!]

  """Checks for any expressions in this list."""
  or: [AnimeLicensorFilter!]

  """Negates the expression."""
  not: AnimeLicensorFilter
}

"""A `AnimeLicensor` edge in the connection."""
type AnimeLicensorsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AnimeLicensor` at the end of the edge."""
  node: AnimeLicensor!
}

"""A connection to a list of `AnimeProducer` values."""
type AnimeProducersConnection {
  """A list of `AnimeProducer` objects."""
  nodes: [AnimeProducer!]!

  """
  A list of edges which contains the `AnimeProducer` and cursor to aid in pagination.
  """
  edges: [AnimeProducersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AnimeProducer` you could get from the connection."""
  totalCount: Int!
}

type AnimeProducer implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  animeId: UUID!
  producerId: UUID!

  """Reads a single `Anime` that is related to this `AnimeProducer`."""
  anime: Anime

  """Reads a single `Producer` that is related to this `AnimeProducer`."""
  producer: Producer
}

type Producer implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  producer: String!

  """Reads and enables pagination through a set of `AnimeProducer`."""
  animeProducers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeProducer`."""
    orderBy: [AnimeProducersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeProducerCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeProducerFilter
  ): AnimeProducersConnection!
}

"""Methods to use when ordering `AnimeProducer`."""
enum AnimeProducersOrderBy {
  NATURAL
  ANIME_ID_ASC
  ANIME_ID_DESC
  PRODUCER_ID_ASC
  PRODUCER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_BY_ANIME_ID__ID_ASC
  ANIME_BY_ANIME_ID__ID_DESC
  ANIME_BY_ANIME_ID__MAL_ID_ASC
  ANIME_BY_ANIME_ID__MAL_ID_DESC
  ANIME_BY_ANIME_ID__TITLE_ASC
  ANIME_BY_ANIME_ID__TITLE_DESC
  ANIME_BY_ANIME_ID__DESCRIPTION_ASC
  ANIME_BY_ANIME_ID__DESCRIPTION_DESC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_ASC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_DESC
  ANIME_BY_ANIME_ID__DURATION_ASC
  ANIME_BY_ANIME_ID__DURATION_DESC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_ASC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_DESC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_ASC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_DESC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_ASC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_DESC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_ASC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_DESC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_ASC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_DESC
  ANIME_BY_ANIME_ID__COVER_IMAGE_ASC
  ANIME_BY_ANIME_ID__COVER_IMAGE_DESC
  ANIME_BY_ANIME_ID__SEASON_ASC
  ANIME_BY_ANIME_ID__SEASON_DESC
  ANIME_BY_ANIME_ID__SEASON_YEAR_ASC
  ANIME_BY_ANIME_ID__SEASON_YEAR_DESC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_ASC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_DESC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_ASC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_DESC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_ASC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_DESC
  PRODUCER_BY_PRODUCER_ID__ID_ASC
  PRODUCER_BY_PRODUCER_ID__ID_DESC
  PRODUCER_BY_PRODUCER_ID__PRODUCER_ASC
  PRODUCER_BY_PRODUCER_ID__PRODUCER_DESC
}

"""
A condition to be used against `AnimeProducer` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input AnimeProducerCondition {
  """Checks for equality with the object’s `animeId` field."""
  animeId: UUID

  """Checks for equality with the object’s `producerId` field."""
  producerId: UUID
}

"""
A filter to be used against `AnimeProducer` object types. All fields are combined with a logical ‘and.’
"""
input AnimeProducerFilter {
  """Filter by the object’s `animeId` field."""
  animeId: UUIDFilter

  """Filter by the object’s `producerId` field."""
  producerId: UUIDFilter

  """Checks for all expressions in this list."""
  and: [AnimeProducerFilter!]

  """Checks for any expressions in this list."""
  or: [AnimeProducerFilter!]

  """Negates the expression."""
  not: AnimeProducerFilter
}

"""A `AnimeProducer` edge in the connection."""
type AnimeProducersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AnimeProducer` at the end of the edge."""
  node: AnimeProducer!
}

"""A connection to a list of `AnimeStudio` values."""
type AnimeStudiosConnection {
  """A list of `AnimeStudio` objects."""
  nodes: [AnimeStudio!]!

  """
  A list of edges which contains the `AnimeStudio` and cursor to aid in pagination.
  """
  edges: [AnimeStudiosEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AnimeStudio` you could get from the connection."""
  totalCount: Int!
}

type AnimeStudio implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  animeId: UUID!
  studioId: UUID!

  """Reads a single `Anime` that is related to this `AnimeStudio`."""
  anime: Anime

  """Reads a single `Studio` that is related to this `AnimeStudio`."""
  studio: Studio
}

type Studio implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  studio: String!

  """Reads and enables pagination through a set of `AnimeStudio`."""
  animeStudios(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AnimeStudio`."""
    orderBy: [AnimeStudiosOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AnimeStudioCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AnimeStudioFilter
  ): AnimeStudiosConnection!
}

"""Methods to use when ordering `AnimeStudio`."""
enum AnimeStudiosOrderBy {
  NATURAL
  ANIME_ID_ASC
  ANIME_ID_DESC
  STUDIO_ID_ASC
  STUDIO_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_BY_ANIME_ID__ID_ASC
  ANIME_BY_ANIME_ID__ID_DESC
  ANIME_BY_ANIME_ID__MAL_ID_ASC
  ANIME_BY_ANIME_ID__MAL_ID_DESC
  ANIME_BY_ANIME_ID__TITLE_ASC
  ANIME_BY_ANIME_ID__TITLE_DESC
  ANIME_BY_ANIME_ID__DESCRIPTION_ASC
  ANIME_BY_ANIME_ID__DESCRIPTION_DESC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_ASC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_DESC
  ANIME_BY_ANIME_ID__DURATION_ASC
  ANIME_BY_ANIME_ID__DURATION_DESC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_ASC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_DESC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_ASC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_DESC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_ASC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_DESC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_ASC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_DESC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_ASC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_DESC
  ANIME_BY_ANIME_ID__COVER_IMAGE_ASC
  ANIME_BY_ANIME_ID__COVER_IMAGE_DESC
  ANIME_BY_ANIME_ID__SEASON_ASC
  ANIME_BY_ANIME_ID__SEASON_DESC
  ANIME_BY_ANIME_ID__SEASON_YEAR_ASC
  ANIME_BY_ANIME_ID__SEASON_YEAR_DESC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_ASC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_DESC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_ASC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_DESC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_ASC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_DESC
  STUDIO_BY_STUDIO_ID__ID_ASC
  STUDIO_BY_STUDIO_ID__ID_DESC
  STUDIO_BY_STUDIO_ID__STUDIO_ASC
  STUDIO_BY_STUDIO_ID__STUDIO_DESC
}

"""
A condition to be used against `AnimeStudio` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input AnimeStudioCondition {
  """Checks for equality with the object’s `animeId` field."""
  animeId: UUID

  """Checks for equality with the object’s `studioId` field."""
  studioId: UUID
}

"""
A filter to be used against `AnimeStudio` object types. All fields are combined with a logical ‘and.’
"""
input AnimeStudioFilter {
  """Filter by the object’s `animeId` field."""
  animeId: UUIDFilter

  """Filter by the object’s `studioId` field."""
  studioId: UUIDFilter

  """Checks for all expressions in this list."""
  and: [AnimeStudioFilter!]

  """Checks for any expressions in this list."""
  or: [AnimeStudioFilter!]

  """Negates the expression."""
  not: AnimeStudioFilter
}

"""A `AnimeStudio` edge in the connection."""
type AnimeStudiosEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AnimeStudio` at the end of the edge."""
  node: AnimeStudio!
}

"""A connection to a list of `AnimeStreamingOn` values."""
type AnimeStreamingOnsConnection {
  """A list of `AnimeStreamingOn` objects."""
  nodes: [AnimeStreamingOn!]!

  """
  A list of edges which contains the `AnimeStreamingOn` and cursor to aid in pagination.
  """
  edges: [AnimeStreamingOnsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `AnimeStreamingOn` you could get from the connection.
  """
  totalCount: Int!
}

type AnimeStreamingOn implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  animeId: UUID!
  streamServiceId: StreamingServices!
  url: String

  """Reads a single `Anime` that is related to this `AnimeStreamingOn`."""
  anime: Anime
}

enum StreamingServices {
  CRUNCHYROLL
}

"""A `AnimeStreamingOn` edge in the connection."""
type AnimeStreamingOnsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AnimeStreamingOn` at the end of the edge."""
  node: AnimeStreamingOn!
}

"""Methods to use when ordering `AnimeStreamingOn`."""
enum AnimeStreamingOnsOrderBy {
  NATURAL
  ANIME_ID_ASC
  ANIME_ID_DESC
  STREAM_SERVICE_ID_ASC
  STREAM_SERVICE_ID_DESC
  URL_ASC
  URL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_BY_ANIME_ID__ID_ASC
  ANIME_BY_ANIME_ID__ID_DESC
  ANIME_BY_ANIME_ID__MAL_ID_ASC
  ANIME_BY_ANIME_ID__MAL_ID_DESC
  ANIME_BY_ANIME_ID__TITLE_ASC
  ANIME_BY_ANIME_ID__TITLE_DESC
  ANIME_BY_ANIME_ID__DESCRIPTION_ASC
  ANIME_BY_ANIME_ID__DESCRIPTION_DESC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_ASC
  ANIME_BY_ANIME_ID__NUMBER_OF_EPISODES_DESC
  ANIME_BY_ANIME_ID__DURATION_ASC
  ANIME_BY_ANIME_ID__DURATION_DESC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_ASC
  ANIME_BY_ANIME_ID__AVERAGE_WATCHER_RATING_DESC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__START_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_ASC
  ANIME_BY_ANIME_ID__END_BROADCAST_DATETIME_DESC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_ASC
  ANIME_BY_ANIME_ID__AGE_RATING_TYPE_DESC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_ASC
  ANIME_BY_ANIME_ID__AIRING_STATUS_TYPE_DESC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_ASC
  ANIME_BY_ANIME_ID__MEDIA_TYPE_DESC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_ASC
  ANIME_BY_ANIME_ID__SOURCE_MATERIAL_TYPE_DESC
  ANIME_BY_ANIME_ID__COVER_IMAGE_ASC
  ANIME_BY_ANIME_ID__COVER_IMAGE_DESC
  ANIME_BY_ANIME_ID__SEASON_ASC
  ANIME_BY_ANIME_ID__SEASON_DESC
  ANIME_BY_ANIME_ID__SEASON_YEAR_ASC
  ANIME_BY_ANIME_ID__SEASON_YEAR_DESC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_ASC
  ANIME_BY_ANIME_ID__YOUTUBE_TRAILER_ID_DESC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_ASC
  ANIME_BY_ANIME_ID__TWITTER_HANDLE_DESC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_ASC
  ANIME_BY_ANIME_ID__OFFICIAL_WEBSITE_DESC
}

"""
A condition to be used against `AnimeStreamingOn` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input AnimeStreamingOnCondition {
  """Checks for equality with the object’s `animeId` field."""
  animeId: UUID

  """Checks for equality with the object’s `streamServiceId` field."""
  streamServiceId: StreamingServices

  """Checks for equality with the object’s `url` field."""
  url: String
}

"""
A filter to be used against `AnimeStreamingOn` object types. All fields are combined with a logical ‘and.’
"""
input AnimeStreamingOnFilter {
  """Filter by the object’s `animeId` field."""
  animeId: UUIDFilter

  """Filter by the object’s `streamServiceId` field."""
  streamServiceId: StreamingServicesFilter

  """Filter by the object’s `url` field."""
  url: StringFilter

  """Checks for all expressions in this list."""
  and: [AnimeStreamingOnFilter!]

  """Checks for any expressions in this list."""
  or: [AnimeStreamingOnFilter!]

  """Negates the expression."""
  not: AnimeStreamingOnFilter
}

"""
A filter to be used against StreamingServices fields. All fields are combined with a logical ‘and.’
"""
input StreamingServicesFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: StreamingServices

  """Not equal to the specified value."""
  notEqualTo: StreamingServices

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: StreamingServices

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: StreamingServices

  """Included in the specified list."""
  in: [StreamingServices!]

  """Not included in the specified list."""
  notIn: [StreamingServices!]

  """Less than the specified value."""
  lessThan: StreamingServices

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: StreamingServices

  """Greater than the specified value."""
  greaterThan: StreamingServices

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: StreamingServices
}

"""A connection to a list of `StaffResult` values."""
type StaffResultsConnection {
  """A list of `StaffResult` objects."""
  nodes: [StaffResult!]!

  """
  A list of edges which contains the `StaffResult` and cursor to aid in pagination.
  """
  edges: [StaffResultsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `StaffResult` you could get from the connection."""
  totalCount: Int!
}

type StaffResult {
  animeId: String
  characterId: String
  characterName: String
  characterImage: String
  actorFirstName: String
  actorLastName: String
  personId: String
  actorImage: String
  characterRole: String
  language: String
}

"""A `StaffResult` edge in the connection."""
type StaffResultsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `StaffResult` at the end of the edge."""
  node: StaffResult!
}

"""
A filter to be used against `StaffResult` object types. All fields are combined with a logical ‘and.’
"""
input StaffResultFilter {
  """Filter by the object’s `animeId` field."""
  animeId: StringFilter

  """Filter by the object’s `characterId` field."""
  characterId: StringFilter

  """Filter by the object’s `characterName` field."""
  characterName: StringFilter

  """Filter by the object’s `characterImage` field."""
  characterImage: StringFilter

  """Filter by the object’s `actorFirstName` field."""
  actorFirstName: StringFilter

  """Filter by the object’s `actorLastName` field."""
  actorLastName: StringFilter

  """Filter by the object’s `personId` field."""
  personId: StringFilter

  """Filter by the object’s `actorImage` field."""
  actorImage: StringFilter

  """Filter by the object’s `characterRole` field."""
  characterRole: StringFilter

  """Filter by the object’s `language` field."""
  language: StringFilter

  """Checks for all expressions in this list."""
  and: [StaffResultFilter!]

  """Checks for any expressions in this list."""
  or: [StaffResultFilter!]

  """Negates the expression."""
  not: StaffResultFilter
}

"""A connection to a list of `Genre` values."""
type GenresConnection {
  """A list of `Genre` objects."""
  nodes: [Genre!]!

  """
  A list of edges which contains the `Genre` and cursor to aid in pagination.
  """
  edges: [GenresEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Genre` you could get from the connection."""
  totalCount: Int!
}

"""A `Genre` edge in the connection."""
type GenresEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Genre` at the end of the edge."""
  node: Genre!
}

"""
A filter to be used against `Genre` object types. All fields are combined with a logical ‘and.’
"""
input GenreFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `genre` field."""
  genre: StringFilter

  """Checks for all expressions in this list."""
  and: [GenreFilter!]

  """Checks for any expressions in this list."""
  or: [GenreFilter!]

  """Negates the expression."""
  not: GenreFilter
}

"""A connection to a list of `Licensor` values."""
type LicensorsConnection {
  """A list of `Licensor` objects."""
  nodes: [Licensor!]!

  """
  A list of edges which contains the `Licensor` and cursor to aid in pagination.
  """
  edges: [LicensorsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Licensor` you could get from the connection."""
  totalCount: Int!
}

"""A `Licensor` edge in the connection."""
type LicensorsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Licensor` at the end of the edge."""
  node: Licensor!
}

"""
A filter to be used against `Licensor` object types. All fields are combined with a logical ‘and.’
"""
input LicensorFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `licensor` field."""
  licensor: StringFilter

  """Checks for all expressions in this list."""
  and: [LicensorFilter!]

  """Checks for any expressions in this list."""
  or: [LicensorFilter!]

  """Negates the expression."""
  not: LicensorFilter
}

"""A connection to a list of `Producer` values."""
type ProducersConnection {
  """A list of `Producer` objects."""
  nodes: [Producer!]!

  """
  A list of edges which contains the `Producer` and cursor to aid in pagination.
  """
  edges: [ProducersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Producer` you could get from the connection."""
  totalCount: Int!
}

"""A `Producer` edge in the connection."""
type ProducersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Producer` at the end of the edge."""
  node: Producer!
}

"""
A filter to be used against `Producer` object types. All fields are combined with a logical ‘and.’
"""
input ProducerFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `producer` field."""
  producer: StringFilter

  """Checks for all expressions in this list."""
  and: [ProducerFilter!]

  """Checks for any expressions in this list."""
  or: [ProducerFilter!]

  """Negates the expression."""
  not: ProducerFilter
}

"""A connection to a list of `Studio` values."""
type StudiosConnection {
  """A list of `Studio` objects."""
  nodes: [Studio!]!

  """
  A list of edges which contains the `Studio` and cursor to aid in pagination.
  """
  edges: [StudiosEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Studio` you could get from the connection."""
  totalCount: Int!
}

"""A `Studio` edge in the connection."""
type StudiosEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Studio` at the end of the edge."""
  node: Studio!
}

"""
A filter to be used against `Studio` object types. All fields are combined with a logical ‘and.’
"""
input StudioFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `studio` field."""
  studio: StringFilter

  """Checks for all expressions in this list."""
  and: [StudioFilter!]

  """Checks for any expressions in this list."""
  or: [StudioFilter!]

  """Negates the expression."""
  not: StudioFilter
}

"""A `AlternateAnimeName` edge in the connection."""
type AlternateAnimeNamesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AlternateAnimeName` at the end of the edge."""
  node: AlternateAnimeName!
}

"""A connection to a list of `Anime` values."""
type AnimeConnection {
  """A list of `Anime` objects."""
  nodes: [Anime!]!

  """
  A list of edges which contains the `Anime` and cursor to aid in pagination.
  """
  edges: [AnimeEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Anime` you could get from the connection."""
  totalCount: Int!
}

"""A `Anime` edge in the connection."""
type AnimeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Anime` at the end of the edge."""
  node: Anime!
}

"""Methods to use when ordering `Anime`."""
enum AnimeOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MAL_ID_ASC
  MAL_ID_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  NUMBER_OF_EPISODES_ASC
  NUMBER_OF_EPISODES_DESC
  DURATION_ASC
  DURATION_DESC
  AVERAGE_WATCHER_RATING_ASC
  AVERAGE_WATCHER_RATING_DESC
  START_BROADCAST_DATETIME_ASC
  START_BROADCAST_DATETIME_DESC
  END_BROADCAST_DATETIME_ASC
  END_BROADCAST_DATETIME_DESC
  AGE_RATING_TYPE_ASC
  AGE_RATING_TYPE_DESC
  AIRING_STATUS_TYPE_ASC
  AIRING_STATUS_TYPE_DESC
  MEDIA_TYPE_ASC
  MEDIA_TYPE_DESC
  SOURCE_MATERIAL_TYPE_ASC
  SOURCE_MATERIAL_TYPE_DESC
  COVER_IMAGE_ASC
  COVER_IMAGE_DESC
  SEASON_ASC
  SEASON_DESC
  SEASON_YEAR_ASC
  SEASON_YEAR_DESC
  YOUTUBE_TRAILER_ID_ASC
  YOUTUBE_TRAILER_ID_DESC
  TWITTER_HANDLE_ASC
  TWITTER_HANDLE_DESC
  OFFICIAL_WEBSITE_ASC
  OFFICIAL_WEBSITE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ANIME_LISTS_BY_ANIME_ID__COUNT_ASC
  USER_ANIME_LISTS_BY_ANIME_ID__COUNT_DESC
  ANIME_USER_SCORES_BY_ANIME_ID__COUNT_ASC
  ANIME_USER_SCORES_BY_ANIME_ID__COUNT_DESC
  ALTERNATE_ANIME_NAMES_BY_ANIME_ID__COUNT_ASC
  ALTERNATE_ANIME_NAMES_BY_ANIME_ID__COUNT_DESC
  ANIME_CHARACTERS_BY_ANIME_ID__COUNT_ASC
  ANIME_CHARACTERS_BY_ANIME_ID__COUNT_DESC
  ANIME_GENRES_BY_ANIME_ID__COUNT_ASC
  ANIME_GENRES_BY_ANIME_ID__COUNT_DESC
  ANIME_IMAGES_BY_ANIME_ID__COUNT_ASC
  ANIME_IMAGES_BY_ANIME_ID__COUNT_DESC
  ANIME_LICENSORS_BY_ANIME_ID__COUNT_ASC
  ANIME_LICENSORS_BY_ANIME_ID__COUNT_DESC
  ANIME_PRODUCERS_BY_ANIME_ID__COUNT_ASC
  ANIME_PRODUCERS_BY_ANIME_ID__COUNT_DESC
  ANIME_STAFF_BY_ANIME_ID__COUNT_ASC
  ANIME_STAFF_BY_ANIME_ID__COUNT_DESC
  ANIME_STUDIOS_BY_ANIME_ID__COUNT_ASC
  ANIME_STUDIOS_BY_ANIME_ID__COUNT_DESC
  USER_ANIME_BY_ANIME_ID__COUNT_ASC
  USER_ANIME_BY_ANIME_ID__COUNT_DESC
  USER_WATCH_STATUSES_BY_ANIME_ID__COUNT_ASC
  USER_WATCH_STATUSES_BY_ANIME_ID__COUNT_DESC
  ANIME_STREAMING_ONS_BY_ANIME_ID__COUNT_ASC
  ANIME_STREAMING_ONS_BY_ANIME_ID__COUNT_DESC
}

"""
A condition to be used against `Anime` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input AnimeCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `malId` field."""
  malId: Int

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `numberOfEpisodes` field."""
  numberOfEpisodes: Int

  """Checks for equality with the object’s `duration` field."""
  duration: Int

  """Checks for equality with the object’s `averageWatcherRating` field."""
  averageWatcherRating: BigFloat

  """Checks for equality with the object’s `startBroadcastDatetime` field."""
  startBroadcastDatetime: Datetime

  """Checks for equality with the object’s `endBroadcastDatetime` field."""
  endBroadcastDatetime: Datetime

  """Checks for equality with the object’s `ageRatingType` field."""
  ageRatingType: AgeRatingTypes

  """Checks for equality with the object’s `airingStatusType` field."""
  airingStatusType: AiringStatusTypes

  """Checks for equality with the object’s `mediaType` field."""
  mediaType: MediaTypes

  """Checks for equality with the object’s `sourceMaterialType` field."""
  sourceMaterialType: SourceMaterialTypes

  """Checks for equality with the object’s `coverImage` field."""
  coverImage: String

  """Checks for equality with the object’s `season` field."""
  season: Season

  """Checks for equality with the object’s `seasonYear` field."""
  seasonYear: Int

  """Checks for equality with the object’s `youtubeTrailerId` field."""
  youtubeTrailerId: String

  """Checks for equality with the object’s `twitterHandle` field."""
  twitterHandle: String

  """Checks for equality with the object’s `officialWebsite` field."""
  officialWebsite: String
}

"""
A filter to be used against `Anime` object types. All fields are combined with a logical ‘and.’
"""
input AnimeFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `malId` field."""
  malId: IntFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `description` field."""
  description: StringFilter

  """Filter by the object’s `numberOfEpisodes` field."""
  numberOfEpisodes: IntFilter

  """Filter by the object’s `duration` field."""
  duration: IntFilter

  """Filter by the object’s `averageWatcherRating` field."""
  averageWatcherRating: BigFloatFilter

  """Filter by the object’s `startBroadcastDatetime` field."""
  startBroadcastDatetime: DatetimeFilter

  """Filter by the object’s `endBroadcastDatetime` field."""
  endBroadcastDatetime: DatetimeFilter

  """Filter by the object’s `ageRatingType` field."""
  ageRatingType: AgeRatingTypesFilter

  """Filter by the object’s `airingStatusType` field."""
  airingStatusType: AiringStatusTypesFilter

  """Filter by the object’s `mediaType` field."""
  mediaType: MediaTypesFilter

  """Filter by the object’s `sourceMaterialType` field."""
  sourceMaterialType: SourceMaterialTypesFilter

  """Filter by the object’s `coverImage` field."""
  coverImage: StringFilter

  """Filter by the object’s `season` field."""
  season: SeasonFilter

  """Filter by the object’s `seasonYear` field."""
  seasonYear: IntFilter

  """Filter by the object’s `youtubeTrailerId` field."""
  youtubeTrailerId: StringFilter

  """Filter by the object’s `twitterHandle` field."""
  twitterHandle: StringFilter

  """Filter by the object’s `officialWebsite` field."""
  officialWebsite: StringFilter

  """Filter by the object’s `allNamesString` field."""
  allNamesString: StringFilter

  """Filter by the object’s `userEpisodeCount` field."""
  userEpisodeCount: BigFloatFilter

  """Filter by the object’s `userLiked` field."""
  userLiked: BooleanFilter

  """Filter by the object’s `userRating` field."""
  userRating: BigFloatFilter

  """Filter by the object’s `userWatchStatus` field."""
  userWatchStatus: StringFilter

  """Checks for all expressions in this list."""
  and: [AnimeFilter!]

  """Checks for any expressions in this list."""
  or: [AnimeFilter!]

  """Negates the expression."""
  not: AnimeFilter
}

"""
A filter to be used against AgeRatingTypes fields. All fields are combined with a logical ‘and.’
"""
input AgeRatingTypesFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: AgeRatingTypes

  """Not equal to the specified value."""
  notEqualTo: AgeRatingTypes

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: AgeRatingTypes

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: AgeRatingTypes

  """Included in the specified list."""
  in: [AgeRatingTypes!]

  """Not included in the specified list."""
  notIn: [AgeRatingTypes!]

  """Less than the specified value."""
  lessThan: AgeRatingTypes

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: AgeRatingTypes

  """Greater than the specified value."""
  greaterThan: AgeRatingTypes

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: AgeRatingTypes
}

"""
A filter to be used against AiringStatusTypes fields. All fields are combined with a logical ‘and.’
"""
input AiringStatusTypesFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: AiringStatusTypes

  """Not equal to the specified value."""
  notEqualTo: AiringStatusTypes

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: AiringStatusTypes

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: AiringStatusTypes

  """Included in the specified list."""
  in: [AiringStatusTypes!]

  """Not included in the specified list."""
  notIn: [AiringStatusTypes!]

  """Less than the specified value."""
  lessThan: AiringStatusTypes

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: AiringStatusTypes

  """Greater than the specified value."""
  greaterThan: AiringStatusTypes

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: AiringStatusTypes
}

"""
A filter to be used against MediaTypes fields. All fields are combined with a logical ‘and.’
"""
input MediaTypesFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: MediaTypes

  """Not equal to the specified value."""
  notEqualTo: MediaTypes

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: MediaTypes

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: MediaTypes

  """Included in the specified list."""
  in: [MediaTypes!]

  """Not included in the specified list."""
  notIn: [MediaTypes!]

  """Less than the specified value."""
  lessThan: MediaTypes

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: MediaTypes

  """Greater than the specified value."""
  greaterThan: MediaTypes

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: MediaTypes
}

"""
A filter to be used against SourceMaterialTypes fields. All fields are combined with a logical ‘and.’
"""
input SourceMaterialTypesFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: SourceMaterialTypes

  """Not equal to the specified value."""
  notEqualTo: SourceMaterialTypes

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: SourceMaterialTypes

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: SourceMaterialTypes

  """Included in the specified list."""
  in: [SourceMaterialTypes!]

  """Not included in the specified list."""
  notIn: [SourceMaterialTypes!]

  """Less than the specified value."""
  lessThan: SourceMaterialTypes

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: SourceMaterialTypes

  """Greater than the specified value."""
  greaterThan: SourceMaterialTypes

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: SourceMaterialTypes
}

"""
A filter to be used against Season fields. All fields are combined with a logical ‘and.’
"""
input SeasonFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Season

  """Not equal to the specified value."""
  notEqualTo: Season

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Season

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Season

  """Included in the specified list."""
  in: [Season!]

  """Not included in the specified list."""
  notIn: [Season!]

  """Less than the specified value."""
  lessThan: Season

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Season

  """Greater than the specified value."""
  greaterThan: Season

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Season
}

"""A connection to a list of `AvailableLanguage` values."""
type AvailableLanguagesConnection {
  """A list of `AvailableLanguage` objects."""
  nodes: [AvailableLanguage!]!

  """
  A list of edges which contains the `AvailableLanguage` and cursor to aid in pagination.
  """
  edges: [AvailableLanguagesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `AvailableLanguage` you could get from the connection.
  """
  totalCount: Int!
}

type AvailableLanguage {
  language: String
  id: BigInt
}

"""A `AvailableLanguage` edge in the connection."""
type AvailableLanguagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AvailableLanguage` at the end of the edge."""
  node: AvailableLanguage!
}

"""Methods to use when ordering `AvailableLanguage`."""
enum AvailableLanguagesOrderBy {
  NATURAL
  LANGUAGE_ASC
  LANGUAGE_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against `AvailableLanguage` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input AvailableLanguageCondition {
  """Checks for equality with the object’s `language` field."""
  language: String

  """Checks for equality with the object’s `id` field."""
  id: BigInt
}

"""
A filter to be used against `AvailableLanguage` object types. All fields are combined with a logical ‘and.’
"""
input AvailableLanguageFilter {
  """Filter by the object’s `language` field."""
  language: StringFilter

  """Filter by the object’s `id` field."""
  id: BigIntFilter

  """Checks for all expressions in this list."""
  and: [AvailableLanguageFilter!]

  """Checks for any expressions in this list."""
  or: [AvailableLanguageFilter!]

  """Negates the expression."""
  not: AvailableLanguageFilter
}

"""A connection to a list of `CharacterRole` values."""
type CharacterRolesConnection {
  """A list of `CharacterRole` objects."""
  nodes: [CharacterRole!]!

  """
  A list of edges which contains the `CharacterRole` and cursor to aid in pagination.
  """
  edges: [CharacterRolesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `CharacterRole` you could get from the connection."""
  totalCount: Int!
}

"""A `CharacterRole` edge in the connection."""
type CharacterRolesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CharacterRole` at the end of the edge."""
  node: CharacterRole!
}

"""Methods to use when ordering `CharacterRole`."""
enum CharacterRolesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ROLE_ASC
  ROLE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_CHARACTERS_BY_CHARACTER_ROLE_ID__COUNT_ASC
  ANIME_CHARACTERS_BY_CHARACTER_ROLE_ID__COUNT_DESC
}

"""
A condition to be used against `CharacterRole` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CharacterRoleCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `role` field."""
  role: String
}

"""
A filter to be used against `CharacterRole` object types. All fields are combined with a logical ‘and.’
"""
input CharacterRoleFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `role` field."""
  role: StringFilter

  """Checks for all expressions in this list."""
  and: [CharacterRoleFilter!]

  """Checks for any expressions in this list."""
  or: [CharacterRoleFilter!]

  """Negates the expression."""
  not: CharacterRoleFilter
}

"""Methods to use when ordering `Genre`."""
enum GenresOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  GENRE_ASC
  GENRE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_GENRES_BY_GENRE_ID__COUNT_ASC
  ANIME_GENRES_BY_GENRE_ID__COUNT_DESC
}

"""
A condition to be used against `Genre` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input GenreCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `genre` field."""
  genre: String
}

"""A connection to a list of `Image` values."""
type ImagesConnection {
  """A list of `Image` objects."""
  nodes: [Image!]!

  """
  A list of edges which contains the `Image` and cursor to aid in pagination.
  """
  edges: [ImagesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Image` you could get from the connection."""
  totalCount: Int!
}

"""A `Image` edge in the connection."""
type ImagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Image` at the end of the edge."""
  node: Image!
}

"""Methods to use when ordering `Image`."""
enum ImagesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TITLE_ASC
  TITLE_DESC
  URL_ASC
  URL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_IMAGES_BY_IMAGE_ID__COUNT_ASC
  ANIME_IMAGES_BY_IMAGE_ID__COUNT_DESC
  CHARACTER_IMAGES_BY_IMAGE_ID__COUNT_ASC
  CHARACTER_IMAGES_BY_IMAGE_ID__COUNT_DESC
  CHARACTERS_BY_CHARACTER_IMAGE_ID__COUNT_ASC
  CHARACTERS_BY_CHARACTER_IMAGE_ID__COUNT_DESC
  PERSON_IMAGES_BY_IMAGE_ID__COUNT_ASC
  PERSON_IMAGES_BY_IMAGE_ID__COUNT_DESC
  PEOPLE_BY_PERSON_IMAGE_ID__COUNT_ASC
  PEOPLE_BY_PERSON_IMAGE_ID__COUNT_DESC
}

"""
A condition to be used against `Image` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ImageCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `url` field."""
  url: String
}

"""
A filter to be used against `Image` object types. All fields are combined with a logical ‘and.’
"""
input ImageFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `url` field."""
  url: StringFilter

  """Checks for all expressions in this list."""
  and: [ImageFilter!]

  """Checks for any expressions in this list."""
  or: [ImageFilter!]

  """Negates the expression."""
  not: ImageFilter
}

"""Methods to use when ordering `Licensor`."""
enum LicensorsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  LICENSOR_ASC
  LICENSOR_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_LICENSORS_BY_LICENSOR_ID__COUNT_ASC
  ANIME_LICENSORS_BY_LICENSOR_ID__COUNT_DESC
}

"""
A condition to be used against `Licensor` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input LicensorCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `licensor` field."""
  licensor: String
}

"""A connection to a list of `MediaFormat` values."""
type MediaFormatsConnection {
  """A list of `MediaFormat` objects."""
  nodes: [MediaFormat!]!

  """
  A list of edges which contains the `MediaFormat` and cursor to aid in pagination.
  """
  edges: [MediaFormatsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `MediaFormat` you could get from the connection."""
  totalCount: Int!
}

type MediaFormat {
  mediaType: String
  id: BigInt
}

"""A `MediaFormat` edge in the connection."""
type MediaFormatsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `MediaFormat` at the end of the edge."""
  node: MediaFormat!
}

"""Methods to use when ordering `MediaFormat`."""
enum MediaFormatsOrderBy {
  NATURAL
  MEDIA_TYPE_ASC
  MEDIA_TYPE_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against `MediaFormat` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input MediaFormatCondition {
  """Checks for equality with the object’s `mediaType` field."""
  mediaType: String

  """Checks for equality with the object’s `id` field."""
  id: BigInt
}

"""
A filter to be used against `MediaFormat` object types. All fields are combined with a logical ‘and.’
"""
input MediaFormatFilter {
  """Filter by the object’s `mediaType` field."""
  mediaType: StringFilter

  """Filter by the object’s `id` field."""
  id: BigIntFilter

  """Checks for all expressions in this list."""
  and: [MediaFormatFilter!]

  """Checks for any expressions in this list."""
  or: [MediaFormatFilter!]

  """Negates the expression."""
  not: MediaFormatFilter
}

"""Methods to use when ordering `Producer`."""
enum ProducersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  PRODUCER_ASC
  PRODUCER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_PRODUCERS_BY_PRODUCER_ID__COUNT_ASC
  ANIME_PRODUCERS_BY_PRODUCER_ID__COUNT_DESC
}

"""
A condition to be used against `Producer` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ProducerCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `producer` field."""
  producer: String
}

"""A connection to a list of `SourceMaterial` values."""
type SourceMaterialsConnection {
  """A list of `SourceMaterial` objects."""
  nodes: [SourceMaterial!]!

  """
  A list of edges which contains the `SourceMaterial` and cursor to aid in pagination.
  """
  edges: [SourceMaterialsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `SourceMaterial` you could get from the connection."""
  totalCount: Int!
}

type SourceMaterial {
  sourceMaterialType: String
  id: BigInt
}

"""A `SourceMaterial` edge in the connection."""
type SourceMaterialsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `SourceMaterial` at the end of the edge."""
  node: SourceMaterial!
}

"""Methods to use when ordering `SourceMaterial`."""
enum SourceMaterialsOrderBy {
  NATURAL
  SOURCE_MATERIAL_TYPE_ASC
  SOURCE_MATERIAL_TYPE_DESC
  ID_ASC
  ID_DESC
}

"""
A condition to be used against `SourceMaterial` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input SourceMaterialCondition {
  """Checks for equality with the object’s `sourceMaterialType` field."""
  sourceMaterialType: String

  """Checks for equality with the object’s `id` field."""
  id: BigInt
}

"""
A filter to be used against `SourceMaterial` object types. All fields are combined with a logical ‘and.’
"""
input SourceMaterialFilter {
  """Filter by the object’s `sourceMaterialType` field."""
  sourceMaterialType: StringFilter

  """Filter by the object’s `id` field."""
  id: BigIntFilter

  """Checks for all expressions in this list."""
  and: [SourceMaterialFilter!]

  """Checks for any expressions in this list."""
  or: [SourceMaterialFilter!]

  """Negates the expression."""
  not: SourceMaterialFilter
}

"""A connection to a list of `StaffRole` values."""
type StaffRolesConnection {
  """A list of `StaffRole` objects."""
  nodes: [StaffRole!]!

  """
  A list of edges which contains the `StaffRole` and cursor to aid in pagination.
  """
  edges: [StaffRolesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `StaffRole` you could get from the connection."""
  totalCount: Int!
}

"""A `StaffRole` edge in the connection."""
type StaffRolesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `StaffRole` at the end of the edge."""
  node: StaffRole!
}

"""Methods to use when ordering `StaffRole`."""
enum StaffRolesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ROLE_ASC
  ROLE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_STAFF_BY_STAFF_ROLE_ID__COUNT_ASC
  ANIME_STAFF_BY_STAFF_ROLE_ID__COUNT_DESC
}

"""
A condition to be used against `StaffRole` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input StaffRoleCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `role` field."""
  role: String
}

"""
A filter to be used against `StaffRole` object types. All fields are combined with a logical ‘and.’
"""
input StaffRoleFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `role` field."""
  role: StringFilter

  """Checks for all expressions in this list."""
  and: [StaffRoleFilter!]

  """Checks for any expressions in this list."""
  or: [StaffRoleFilter!]

  """Negates the expression."""
  not: StaffRoleFilter
}

"""Methods to use when ordering `Studio`."""
enum StudiosOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  STUDIO_ASC
  STUDIO_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_STUDIOS_BY_STUDIO_ID__COUNT_ASC
  ANIME_STUDIOS_BY_STUDIO_ID__COUNT_DESC
}

"""
A condition to be used against `Studio` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input StudioCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `studio` field."""
  studio: String
}

"""A connection to a list of `User` values."""
type UsersConnection {
  """A list of `User` objects."""
  nodes: [User!]!

  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ANIME_LISTS_BY_USER_ID__COUNT_ASC
  ANIME_LISTS_BY_USER_ID__COUNT_DESC
  ANIME_USER_SCORES_BY_USER_ID__COUNT_ASC
  ANIME_USER_SCORES_BY_USER_ID__COUNT_DESC
  USER_ANIME_BY_USER_ID__COUNT_ASC
  USER_ANIME_BY_USER_ID__COUNT_DESC
  USER_WATCH_STATUSES_BY_USER_ID__COUNT_ASC
  USER_WATCH_STATUSES_BY_USER_ID__COUNT_DESC
  USER_NOTIFICATIONS_BY_USER_ID__COUNT_ASC
  USER_NOTIFICATIONS_BY_USER_ID__COUNT_DESC
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input UserCondition {
  """Checks for equality with the object’s `id` field."""
  id: String
}

"""
A filter to be used against `User` object types. All fields are combined with a logical ‘and.’
"""
input UserFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Checks for all expressions in this list."""
  and: [UserFilter!]

  """Checks for any expressions in this list."""
  or: [UserFilter!]

  """Negates the expression."""
  not: UserFilter
}

"""A connection to a list of `UserAnimeListType` values."""
type UserAnimeListTypesConnection {
  """A list of `UserAnimeListType` objects."""
  nodes: [UserAnimeListType!]!

  """
  A list of edges which contains the `UserAnimeListType` and cursor to aid in pagination.
  """
  edges: [UserAnimeListTypesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `UserAnimeListType` you could get from the connection.
  """
  totalCount: Int!
}

type UserAnimeListType {
  id: UUID
  title: String
  coverImage: String
  listName: String
  listId: UUID
  privacy: AnimeListPrivacy
}

"""A `UserAnimeListType` edge in the connection."""
type UserAnimeListTypesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserAnimeListType` at the end of the edge."""
  node: UserAnimeListType!
}

"""
A filter to be used against `UserAnimeListType` object types. All fields are combined with a logical ‘and.’
"""
input UserAnimeListTypeFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `coverImage` field."""
  coverImage: StringFilter

  """Filter by the object’s `listName` field."""
  listName: StringFilter

  """Filter by the object’s `listId` field."""
  listId: UUIDFilter

  """Filter by the object’s `privacy` field."""
  privacy: AnimeListPrivacyFilter

  """Checks for all expressions in this list."""
  and: [UserAnimeListTypeFilter!]

  """Checks for any expressions in this list."""
  or: [UserAnimeListTypeFilter!]

  """Negates the expression."""
  not: UserAnimeListTypeFilter
}

"""A connection to a list of `UserList` values."""
type UserListsConnection {
  """A list of `UserList` objects."""
  nodes: [UserList!]!

  """
  A list of edges which contains the `UserList` and cursor to aid in pagination.
  """
  edges: [UserListsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `UserList` you could get from the connection."""
  totalCount: Int!
}

type UserList {
  id: UUID
  title: String
  userId: String
  animes: [UserListAnime]
}

type UserListAnime {
  id: UUID
  title: String
  coverImage: String
  numberOfEpisodes: BigFloat
  averageWatcherRating: BigFloat
  userLiked: Boolean
  userRating: BigFloat
  userWatchStatus: String
  userEpisodeCount: BigFloat
  startBroadcastDatetime: Datetime
  airingStatusType: String
}

"""A `UserList` edge in the connection."""
type UserListsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserList` at the end of the edge."""
  node: UserList!
}

"""
A filter to be used against `UserList` object types. All fields are combined with a logical ‘and.’
"""
input UserListFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `userId` field."""
  userId: StringFilter

  """Checks for all expressions in this list."""
  and: [UserListFilter!]

  """Checks for any expressions in this list."""
  or: [UserListFilter!]

  """Negates the expression."""
  not: UserListFilter
}

type MeType {
  userId: String
  role: String
  username: String
  email: String
}

"""A connection to a list of `SearchResult` values."""
type SearchResultsConnection {
  """A list of `SearchResult` objects."""
  nodes: [SearchResult!]!

  """
  A list of edges which contains the `SearchResult` and cursor to aid in pagination.
  """
  edges: [SearchResultsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `SearchResult` you could get from the connection."""
  totalCount: Int!
}

type SearchResult {
  id: UUID
  malId: Int
  title: String
  description: String
  numberOfEpisodes: Int
  duration: Int
  averageWatcherRating: BigFloat
  startBroadcastDatetime: Datetime
  endBroadcastDatetime: Datetime
  ageRatingType: String
  airingStatusType: String
  mediaType: String
  sourceMaterialType: String
  coverImage: String
  season: String
  seasonYear: Int
  altName: String
  userLiked: Boolean
  userRating: BigFloat
  userWatchStatus: String
  userEpisodeCount: Int
  genres: [String]
  producers: [String]
  studios: [String]
  streamingOn: String
}

"""A `SearchResult` edge in the connection."""
type SearchResultsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `SearchResult` at the end of the edge."""
  node: SearchResult!
}

"""
A filter to be used against `SearchResult` object types. All fields are combined with a logical ‘and.’
"""
input SearchResultFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `malId` field."""
  malId: IntFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `description` field."""
  description: StringFilter

  """Filter by the object’s `numberOfEpisodes` field."""
  numberOfEpisodes: IntFilter

  """Filter by the object’s `duration` field."""
  duration: IntFilter

  """Filter by the object’s `averageWatcherRating` field."""
  averageWatcherRating: BigFloatFilter

  """Filter by the object’s `startBroadcastDatetime` field."""
  startBroadcastDatetime: DatetimeFilter

  """Filter by the object’s `endBroadcastDatetime` field."""
  endBroadcastDatetime: DatetimeFilter

  """Filter by the object’s `ageRatingType` field."""
  ageRatingType: StringFilter

  """Filter by the object’s `airingStatusType` field."""
  airingStatusType: StringFilter

  """Filter by the object’s `mediaType` field."""
  mediaType: StringFilter

  """Filter by the object’s `sourceMaterialType` field."""
  sourceMaterialType: StringFilter

  """Filter by the object’s `coverImage` field."""
  coverImage: StringFilter

  """Filter by the object’s `season` field."""
  season: StringFilter

  """Filter by the object’s `seasonYear` field."""
  seasonYear: IntFilter

  """Filter by the object’s `altName` field."""
  altName: StringFilter

  """Filter by the object’s `userLiked` field."""
  userLiked: BooleanFilter

  """Filter by the object’s `userRating` field."""
  userRating: BigFloatFilter

  """Filter by the object’s `userWatchStatus` field."""
  userWatchStatus: StringFilter

  """Filter by the object’s `userEpisodeCount` field."""
  userEpisodeCount: IntFilter

  """Filter by the object’s `genres` field."""
  genres: StringListFilter

  """Filter by the object’s `producers` field."""
  producers: StringListFilter

  """Filter by the object’s `studios` field."""
  studios: StringListFilter

  """Filter by the object’s `streamingOn` field."""
  streamingOn: StringFilter

  """Checks for all expressions in this list."""
  and: [SearchResultFilter!]

  """Checks for any expressions in this list."""
  or: [SearchResultFilter!]

  """Negates the expression."""
  not: SearchResultFilter
}

"""
A filter to be used against String List fields. All fields are combined with a logical ‘and.’
"""
input StringListFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: [String]

  """Not equal to the specified value."""
  notEqualTo: [String]

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: [String]

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: [String]

  """Less than the specified value."""
  lessThan: [String]

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: [String]

  """Greater than the specified value."""
  greaterThan: [String]

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: [String]

  """Contains the specified list of values."""
  contains: [String]

  """Contained by the specified list of values."""
  containedBy: [String]

  """Overlaps the specified list of values."""
  overlaps: [String]

  """Any array item is equal to the specified value."""
  anyEqualTo: String

  """Any array item is not equal to the specified value."""
  anyNotEqualTo: String

  """Any array item is less than the specified value."""
  anyLessThan: String

  """Any array item is less than or equal to the specified value."""
  anyLessThanOrEqualTo: String

  """Any array item is greater than the specified value."""
  anyGreaterThan: String

  """Any array item is greater than or equal to the specified value."""
  anyGreaterThanOrEqualTo: String
}

"""A connection to a list of `CustomAnimeList` values."""
type CustomAnimeListsConnection {
  """A list of `CustomAnimeList` objects."""
  nodes: [CustomAnimeList!]!

  """
  A list of edges which contains the `CustomAnimeList` and cursor to aid in pagination.
  """
  edges: [CustomAnimeListsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `CustomAnimeList` you could get from the connection.
  """
  totalCount: Int!
}

type CustomAnimeList {
  id: String
  listName: String
  title: String
  watchStatus: String
  userEpisodesWatched: Int
  numberOfEpisodes: Int
  userScore: BigFloat
  mediaType: String
  animeId: UUID
  imageUrl: String
  averageWatcherRating: BigFloat
  animeIndex: String
}

"""A `CustomAnimeList` edge in the connection."""
type CustomAnimeListsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CustomAnimeList` at the end of the edge."""
  node: CustomAnimeList!
}

"""
A filter to be used against `CustomAnimeList` object types. All fields are combined with a logical ‘and.’
"""
input CustomAnimeListFilter {
  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `listName` field."""
  listName: StringFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `watchStatus` field."""
  watchStatus: StringFilter

  """Filter by the object’s `userEpisodesWatched` field."""
  userEpisodesWatched: IntFilter

  """Filter by the object’s `numberOfEpisodes` field."""
  numberOfEpisodes: IntFilter

  """Filter by the object’s `userScore` field."""
  userScore: BigFloatFilter

  """Filter by the object’s `mediaType` field."""
  mediaType: StringFilter

  """Filter by the object’s `animeId` field."""
  animeId: UUIDFilter

  """Filter by the object’s `imageUrl` field."""
  imageUrl: StringFilter

  """Filter by the object’s `averageWatcherRating` field."""
  averageWatcherRating: BigFloatFilter

  """Filter by the object’s `animeIndex` field."""
  animeIndex: StringFilter

  """Checks for all expressions in this list."""
  and: [CustomAnimeListFilter!]

  """Checks for any expressions in this list."""
  or: [CustomAnimeListFilter!]

  """Negates the expression."""
  not: CustomAnimeListFilter
}

"""A connection to a list of `UserCustomAnimeListByStatusType` values."""
type UserCustomAnimeListByStatusTypesConnection {
  """A list of `UserCustomAnimeListByStatusType` objects."""
  nodes: [UserCustomAnimeListByStatusType!]!

  """
  A list of edges which contains the `UserCustomAnimeListByStatusType` and cursor to aid in pagination.
  """
  edges: [UserCustomAnimeListByStatusTypesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `UserCustomAnimeListByStatusType` you could get from the connection.
  """
  totalCount: Int!
}

type UserCustomAnimeListByStatusType {
  id: UUID
  title: String
  watchStatus: String
  userEpisodesWatched: BigFloat
  numberOfEpisodes: BigFloat
  userScore: BigFloat
  mediaType: String
  imageUrl: String
  averageWatcherRating: BigFloat
}

"""A `UserCustomAnimeListByStatusType` edge in the connection."""
type UserCustomAnimeListByStatusTypesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserCustomAnimeListByStatusType` at the end of the edge."""
  node: UserCustomAnimeListByStatusType!
}

"""
A filter to be used against `UserCustomAnimeListByStatusType` object types. All fields are combined with a logical ‘and.’
"""
input UserCustomAnimeListByStatusTypeFilter {
  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `title` field."""
  title: StringFilter

  """Filter by the object’s `watchStatus` field."""
  watchStatus: StringFilter

  """Filter by the object’s `userEpisodesWatched` field."""
  userEpisodesWatched: BigFloatFilter

  """Filter by the object’s `numberOfEpisodes` field."""
  numberOfEpisodes: BigFloatFilter

  """Filter by the object’s `userScore` field."""
  userScore: BigFloatFilter

  """Filter by the object’s `mediaType` field."""
  mediaType: StringFilter

  """Filter by the object’s `imageUrl` field."""
  imageUrl: StringFilter

  """Filter by the object’s `averageWatcherRating` field."""
  averageWatcherRating: BigFloatFilter

  """Checks for all expressions in this list."""
  and: [UserCustomAnimeListByStatusTypeFilter!]

  """Checks for any expressions in this list."""
  or: [UserCustomAnimeListByStatusTypeFilter!]

  """Negates the expression."""
  not: UserCustomAnimeListByStatusTypeFilter
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `AlternateAnimeName`."""
  createAlternateAnimeName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAlternateAnimeNameInput!
  ): CreateAlternateAnimeNamePayload

  """Creates a single `AnimeCharacter`."""
  createAnimeCharacter(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAnimeCharacterInput!
  ): CreateAnimeCharacterPayload

  """Creates a single `AnimeGenre`."""
  createAnimeGenre(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAnimeGenreInput!
  ): CreateAnimeGenrePayload

  """Creates a single `AnimeImage`."""
  createAnimeImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAnimeImageInput!
  ): CreateAnimeImagePayload

  """Creates a single `AnimeLicensor`."""
  createAnimeLicensor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAnimeLicensorInput!
  ): CreateAnimeLicensorPayload

  """Creates a single `AnimeList`."""
  createAnimeList(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAnimeListInput!
  ): CreateAnimeListPayload

  """Creates a single `AnimeProducer`."""
  createAnimeProducer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAnimeProducerInput!
  ): CreateAnimeProducerPayload

  """Creates a single `AnimeStaff`."""
  createAnimeStaff(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAnimeStaffInput!
  ): CreateAnimeStaffPayload

  """Creates a single `AnimeStreamingOn`."""
  createAnimeStreamingOn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAnimeStreamingOnInput!
  ): CreateAnimeStreamingOnPayload

  """Creates a single `AnimeStudio`."""
  createAnimeStudio(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAnimeStudioInput!
  ): CreateAnimeStudioPayload

  """Creates a single `AnimeUserScore`."""
  createAnimeUserScore(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAnimeUserScoreInput!
  ): CreateAnimeUserScorePayload

  """Creates a single `Anime`."""
  createAnime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAnimeInput!
  ): CreateAnimePayload

  """Creates a single `CharacterImage`."""
  createCharacterImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCharacterImageInput!
  ): CreateCharacterImagePayload

  """Creates a single `CharacterRole`."""
  createCharacterRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCharacterRoleInput!
  ): CreateCharacterRolePayload

  """Creates a single `Character`."""
  createCharacter(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCharacterInput!
  ): CreateCharacterPayload

  """Creates a single `Genre`."""
  createGenre(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateGenreInput!
  ): CreateGenrePayload

  """Creates a single `Image`."""
  createImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateImageInput!
  ): CreateImagePayload

  """Creates a single `Licensor`."""
  createLicensor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLicensorInput!
  ): CreateLicensorPayload

  """Creates a single `PersonImage`."""
  createPersonImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePersonImageInput!
  ): CreatePersonImagePayload

  """Creates a single `Person`."""
  createPerson(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePersonInput!
  ): CreatePersonPayload

  """Creates a single `Producer`."""
  createProducer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProducerInput!
  ): CreateProducerPayload

  """Creates a single `StaffRole`."""
  createStaffRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStaffRoleInput!
  ): CreateStaffRolePayload

  """Creates a single `Studio`."""
  createStudio(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStudioInput!
  ): CreateStudioPayload

  """Creates a single `UserAnime`."""
  createUserAnime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserAnimeInput!
  ): CreateUserAnimePayload

  """Creates a single `UserAnimeList`."""
  createUserAnimeList(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserAnimeListInput!
  ): CreateUserAnimeListPayload

  """Creates a single `UserNotification`."""
  createUserNotification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserNotificationInput!
  ): CreateUserNotificationPayload

  """Creates a single `UserWatchStatus`."""
  createUserWatchStatus(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserWatchStatusInput!
  ): CreateUserWatchStatusPayload

  """Creates a single `User`."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """
  Updates a single `AlternateAnimeName` using its globally unique id and a patch.
  """
  updateAlternateAnimeNameByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAlternateAnimeNameByNodeIdInput!
  ): UpdateAlternateAnimeNamePayload

  """Updates a single `AlternateAnimeName` using a unique key and a patch."""
  updateAlternateAnimeName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAlternateAnimeNameInput!
  ): UpdateAlternateAnimeNamePayload

  """
  Updates a single `AnimeCharacter` using its globally unique id and a patch.
  """
  updateAnimeCharacterByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeCharacterByNodeIdInput!
  ): UpdateAnimeCharacterPayload

  """Updates a single `AnimeCharacter` using a unique key and a patch."""
  updateAnimeCharacter(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeCharacterInput!
  ): UpdateAnimeCharacterPayload

  """
  Updates a single `AnimeGenre` using its globally unique id and a patch.
  """
  updateAnimeGenreByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeGenreByNodeIdInput!
  ): UpdateAnimeGenrePayload

  """Updates a single `AnimeGenre` using a unique key and a patch."""
  updateAnimeGenre(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeGenreInput!
  ): UpdateAnimeGenrePayload

  """
  Updates a single `AnimeImage` using its globally unique id and a patch.
  """
  updateAnimeImageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeImageByNodeIdInput!
  ): UpdateAnimeImagePayload

  """Updates a single `AnimeImage` using a unique key and a patch."""
  updateAnimeImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeImageInput!
  ): UpdateAnimeImagePayload

  """
  Updates a single `AnimeLicensor` using its globally unique id and a patch.
  """
  updateAnimeLicensorByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeLicensorByNodeIdInput!
  ): UpdateAnimeLicensorPayload

  """Updates a single `AnimeLicensor` using a unique key and a patch."""
  updateAnimeLicensor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeLicensorInput!
  ): UpdateAnimeLicensorPayload

  """Updates a single `AnimeList` using its globally unique id and a patch."""
  updateAnimeListByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeListByNodeIdInput!
  ): UpdateAnimeListPayload

  """Updates a single `AnimeList` using a unique key and a patch."""
  updateAnimeList(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeListInput!
  ): UpdateAnimeListPayload

  """
  Updates a single `AnimeProducer` using its globally unique id and a patch.
  """
  updateAnimeProducerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeProducerByNodeIdInput!
  ): UpdateAnimeProducerPayload

  """Updates a single `AnimeProducer` using a unique key and a patch."""
  updateAnimeProducer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeProducerInput!
  ): UpdateAnimeProducerPayload

  """
  Updates a single `AnimeStaff` using its globally unique id and a patch.
  """
  updateAnimeStaffByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeStaffByNodeIdInput!
  ): UpdateAnimeStaffPayload

  """Updates a single `AnimeStaff` using a unique key and a patch."""
  updateAnimeStaff(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeStaffInput!
  ): UpdateAnimeStaffPayload

  """
  Updates a single `AnimeStreamingOn` using its globally unique id and a patch.
  """
  updateAnimeStreamingOnByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeStreamingOnByNodeIdInput!
  ): UpdateAnimeStreamingOnPayload

  """Updates a single `AnimeStreamingOn` using a unique key and a patch."""
  updateAnimeStreamingOn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeStreamingOnInput!
  ): UpdateAnimeStreamingOnPayload

  """
  Updates a single `AnimeStudio` using its globally unique id and a patch.
  """
  updateAnimeStudioByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeStudioByNodeIdInput!
  ): UpdateAnimeStudioPayload

  """Updates a single `AnimeStudio` using a unique key and a patch."""
  updateAnimeStudio(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeStudioInput!
  ): UpdateAnimeStudioPayload

  """
  Updates a single `AnimeUserScore` using its globally unique id and a patch.
  """
  updateAnimeUserScoreByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeUserScoreByNodeIdInput!
  ): UpdateAnimeUserScorePayload

  """Updates a single `AnimeUserScore` using a unique key and a patch."""
  updateAnimeUserScore(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeUserScoreInput!
  ): UpdateAnimeUserScorePayload

  """Updates a single `Anime` using its globally unique id and a patch."""
  updateAnimeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeByNodeIdInput!
  ): UpdateAnimePayload

  """Updates a single `Anime` using a unique key and a patch."""
  updateAnime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeInput!
  ): UpdateAnimePayload

  """Updates a single `Anime` using a unique key and a patch."""
  updateAnimeByMalId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAnimeByMalIdInput!
  ): UpdateAnimePayload

  """
  Updates a single `CharacterImage` using its globally unique id and a patch.
  """
  updateCharacterImageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCharacterImageByNodeIdInput!
  ): UpdateCharacterImagePayload

  """Updates a single `CharacterImage` using a unique key and a patch."""
  updateCharacterImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCharacterImageInput!
  ): UpdateCharacterImagePayload

  """
  Updates a single `CharacterRole` using its globally unique id and a patch.
  """
  updateCharacterRoleByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCharacterRoleByNodeIdInput!
  ): UpdateCharacterRolePayload

  """Updates a single `CharacterRole` using a unique key and a patch."""
  updateCharacterRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCharacterRoleInput!
  ): UpdateCharacterRolePayload

  """Updates a single `CharacterRole` using a unique key and a patch."""
  updateCharacterRoleByRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCharacterRoleByRoleInput!
  ): UpdateCharacterRolePayload

  """Updates a single `Character` using its globally unique id and a patch."""
  updateCharacterByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCharacterByNodeIdInput!
  ): UpdateCharacterPayload

  """Updates a single `Character` using a unique key and a patch."""
  updateCharacter(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCharacterInput!
  ): UpdateCharacterPayload

  """Updates a single `Character` using a unique key and a patch."""
  updateCharacterByMalId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCharacterByMalIdInput!
  ): UpdateCharacterPayload

  """Updates a single `Genre` using its globally unique id and a patch."""
  updateGenreByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGenreByNodeIdInput!
  ): UpdateGenrePayload

  """Updates a single `Genre` using a unique key and a patch."""
  updateGenre(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGenreInput!
  ): UpdateGenrePayload

  """Updates a single `Genre` using a unique key and a patch."""
  updateGenreByGenre(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGenreByGenreInput!
  ): UpdateGenrePayload

  """Updates a single `Image` using its globally unique id and a patch."""
  updateImageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateImageByNodeIdInput!
  ): UpdateImagePayload

  """Updates a single `Image` using a unique key and a patch."""
  updateImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateImageInput!
  ): UpdateImagePayload

  """Updates a single `Licensor` using its globally unique id and a patch."""
  updateLicensorByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLicensorByNodeIdInput!
  ): UpdateLicensorPayload

  """Updates a single `Licensor` using a unique key and a patch."""
  updateLicensor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLicensorInput!
  ): UpdateLicensorPayload

  """Updates a single `Licensor` using a unique key and a patch."""
  updateLicensorByLicensor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLicensorByLicensorInput!
  ): UpdateLicensorPayload

  """
  Updates a single `PersonImage` using its globally unique id and a patch.
  """
  updatePersonImageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePersonImageByNodeIdInput!
  ): UpdatePersonImagePayload

  """Updates a single `PersonImage` using a unique key and a patch."""
  updatePersonImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePersonImageInput!
  ): UpdatePersonImagePayload

  """Updates a single `Person` using its globally unique id and a patch."""
  updatePersonByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePersonByNodeIdInput!
  ): UpdatePersonPayload

  """Updates a single `Person` using a unique key and a patch."""
  updatePerson(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePersonInput!
  ): UpdatePersonPayload

  """Updates a single `Person` using a unique key and a patch."""
  updatePersonByMalId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePersonByMalIdInput!
  ): UpdatePersonPayload

  """Updates a single `Producer` using its globally unique id and a patch."""
  updateProducerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProducerByNodeIdInput!
  ): UpdateProducerPayload

  """Updates a single `Producer` using a unique key and a patch."""
  updateProducer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProducerInput!
  ): UpdateProducerPayload

  """Updates a single `Producer` using a unique key and a patch."""
  updateProducerByProducer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProducerByProducerInput!
  ): UpdateProducerPayload

  """Updates a single `StaffRole` using its globally unique id and a patch."""
  updateStaffRoleByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStaffRoleByNodeIdInput!
  ): UpdateStaffRolePayload

  """Updates a single `StaffRole` using a unique key and a patch."""
  updateStaffRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStaffRoleInput!
  ): UpdateStaffRolePayload

  """Updates a single `StaffRole` using a unique key and a patch."""
  updateStaffRoleByRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStaffRoleByRoleInput!
  ): UpdateStaffRolePayload

  """Updates a single `Studio` using its globally unique id and a patch."""
  updateStudioByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStudioByNodeIdInput!
  ): UpdateStudioPayload

  """Updates a single `Studio` using a unique key and a patch."""
  updateStudio(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStudioInput!
  ): UpdateStudioPayload

  """Updates a single `Studio` using a unique key and a patch."""
  updateStudioByStudio(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStudioByStudioInput!
  ): UpdateStudioPayload

  """Updates a single `UserAnime` using its globally unique id and a patch."""
  updateUserAnimeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserAnimeByNodeIdInput!
  ): UpdateUserAnimePayload

  """Updates a single `UserAnime` using a unique key and a patch."""
  updateUserAnime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserAnimeInput!
  ): UpdateUserAnimePayload

  """Updates a single `UserAnimeList` using a unique key and a patch."""
  updateUserAnimeListByAnimeListIdAndAnimeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserAnimeListByAnimeListIdAndAnimeIdInput!
  ): UpdateUserAnimeListPayload

  """
  Updates a single `UserNotification` using its globally unique id and a patch.
  """
  updateUserNotificationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserNotificationByNodeIdInput!
  ): UpdateUserNotificationPayload

  """Updates a single `UserNotification` using a unique key and a patch."""
  updateUserNotification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserNotificationInput!
  ): UpdateUserNotificationPayload

  """
  Updates a single `UserWatchStatus` using its globally unique id and a patch.
  """
  updateUserWatchStatusByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserWatchStatusByNodeIdInput!
  ): UpdateUserWatchStatusPayload

  """Updates a single `UserWatchStatus` using a unique key and a patch."""
  updateUserWatchStatus(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserWatchStatusInput!
  ): UpdateUserWatchStatusPayload

  """Updates a single `User` using its globally unique id and a patch."""
  updateUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserByNodeIdInput!
  ): UpdateUserPayload

  """Updates a single `User` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """Deletes a single `AlternateAnimeName` using its globally unique id."""
  deleteAlternateAnimeNameByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAlternateAnimeNameByNodeIdInput!
  ): DeleteAlternateAnimeNamePayload

  """Deletes a single `AlternateAnimeName` using a unique key."""
  deleteAlternateAnimeName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAlternateAnimeNameInput!
  ): DeleteAlternateAnimeNamePayload

  """Deletes a single `AnimeCharacter` using its globally unique id."""
  deleteAnimeCharacterByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeCharacterByNodeIdInput!
  ): DeleteAnimeCharacterPayload

  """Deletes a single `AnimeCharacter` using a unique key."""
  deleteAnimeCharacter(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeCharacterInput!
  ): DeleteAnimeCharacterPayload

  """Deletes a single `AnimeGenre` using its globally unique id."""
  deleteAnimeGenreByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeGenreByNodeIdInput!
  ): DeleteAnimeGenrePayload

  """Deletes a single `AnimeGenre` using a unique key."""
  deleteAnimeGenre(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeGenreInput!
  ): DeleteAnimeGenrePayload

  """Deletes a single `AnimeImage` using its globally unique id."""
  deleteAnimeImageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeImageByNodeIdInput!
  ): DeleteAnimeImagePayload

  """Deletes a single `AnimeImage` using a unique key."""
  deleteAnimeImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeImageInput!
  ): DeleteAnimeImagePayload

  """Deletes a single `AnimeLicensor` using its globally unique id."""
  deleteAnimeLicensorByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeLicensorByNodeIdInput!
  ): DeleteAnimeLicensorPayload

  """Deletes a single `AnimeLicensor` using a unique key."""
  deleteAnimeLicensor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeLicensorInput!
  ): DeleteAnimeLicensorPayload

  """Deletes a single `AnimeList` using its globally unique id."""
  deleteAnimeListByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeListByNodeIdInput!
  ): DeleteAnimeListPayload

  """Deletes a single `AnimeList` using a unique key."""
  deleteAnimeList(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeListInput!
  ): DeleteAnimeListPayload

  """Deletes a single `AnimeProducer` using its globally unique id."""
  deleteAnimeProducerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeProducerByNodeIdInput!
  ): DeleteAnimeProducerPayload

  """Deletes a single `AnimeProducer` using a unique key."""
  deleteAnimeProducer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeProducerInput!
  ): DeleteAnimeProducerPayload

  """Deletes a single `AnimeStaff` using its globally unique id."""
  deleteAnimeStaffByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeStaffByNodeIdInput!
  ): DeleteAnimeStaffPayload

  """Deletes a single `AnimeStaff` using a unique key."""
  deleteAnimeStaff(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeStaffInput!
  ): DeleteAnimeStaffPayload

  """Deletes a single `AnimeStreamingOn` using its globally unique id."""
  deleteAnimeStreamingOnByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeStreamingOnByNodeIdInput!
  ): DeleteAnimeStreamingOnPayload

  """Deletes a single `AnimeStreamingOn` using a unique key."""
  deleteAnimeStreamingOn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeStreamingOnInput!
  ): DeleteAnimeStreamingOnPayload

  """Deletes a single `AnimeStudio` using its globally unique id."""
  deleteAnimeStudioByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeStudioByNodeIdInput!
  ): DeleteAnimeStudioPayload

  """Deletes a single `AnimeStudio` using a unique key."""
  deleteAnimeStudio(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeStudioInput!
  ): DeleteAnimeStudioPayload

  """Deletes a single `AnimeUserScore` using its globally unique id."""
  deleteAnimeUserScoreByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeUserScoreByNodeIdInput!
  ): DeleteAnimeUserScorePayload

  """Deletes a single `AnimeUserScore` using a unique key."""
  deleteAnimeUserScore(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeUserScoreInput!
  ): DeleteAnimeUserScorePayload

  """Deletes a single `Anime` using its globally unique id."""
  deleteAnimeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeByNodeIdInput!
  ): DeleteAnimePayload

  """Deletes a single `Anime` using a unique key."""
  deleteAnime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeInput!
  ): DeleteAnimePayload

  """Deletes a single `Anime` using a unique key."""
  deleteAnimeByMalId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAnimeByMalIdInput!
  ): DeleteAnimePayload

  """Deletes a single `CharacterImage` using its globally unique id."""
  deleteCharacterImageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCharacterImageByNodeIdInput!
  ): DeleteCharacterImagePayload

  """Deletes a single `CharacterImage` using a unique key."""
  deleteCharacterImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCharacterImageInput!
  ): DeleteCharacterImagePayload

  """Deletes a single `CharacterRole` using its globally unique id."""
  deleteCharacterRoleByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCharacterRoleByNodeIdInput!
  ): DeleteCharacterRolePayload

  """Deletes a single `CharacterRole` using a unique key."""
  deleteCharacterRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCharacterRoleInput!
  ): DeleteCharacterRolePayload

  """Deletes a single `CharacterRole` using a unique key."""
  deleteCharacterRoleByRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCharacterRoleByRoleInput!
  ): DeleteCharacterRolePayload

  """Deletes a single `Character` using its globally unique id."""
  deleteCharacterByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCharacterByNodeIdInput!
  ): DeleteCharacterPayload

  """Deletes a single `Character` using a unique key."""
  deleteCharacter(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCharacterInput!
  ): DeleteCharacterPayload

  """Deletes a single `Character` using a unique key."""
  deleteCharacterByMalId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCharacterByMalIdInput!
  ): DeleteCharacterPayload

  """Deletes a single `Genre` using its globally unique id."""
  deleteGenreByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGenreByNodeIdInput!
  ): DeleteGenrePayload

  """Deletes a single `Genre` using a unique key."""
  deleteGenre(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGenreInput!
  ): DeleteGenrePayload

  """Deletes a single `Genre` using a unique key."""
  deleteGenreByGenre(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGenreByGenreInput!
  ): DeleteGenrePayload

  """Deletes a single `Image` using its globally unique id."""
  deleteImageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteImageByNodeIdInput!
  ): DeleteImagePayload

  """Deletes a single `Image` using a unique key."""
  deleteImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteImageInput!
  ): DeleteImagePayload

  """Deletes a single `Licensor` using its globally unique id."""
  deleteLicensorByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLicensorByNodeIdInput!
  ): DeleteLicensorPayload

  """Deletes a single `Licensor` using a unique key."""
  deleteLicensor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLicensorInput!
  ): DeleteLicensorPayload

  """Deletes a single `Licensor` using a unique key."""
  deleteLicensorByLicensor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLicensorByLicensorInput!
  ): DeleteLicensorPayload

  """Deletes a single `PersonImage` using its globally unique id."""
  deletePersonImageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePersonImageByNodeIdInput!
  ): DeletePersonImagePayload

  """Deletes a single `PersonImage` using a unique key."""
  deletePersonImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePersonImageInput!
  ): DeletePersonImagePayload

  """Deletes a single `Person` using its globally unique id."""
  deletePersonByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePersonByNodeIdInput!
  ): DeletePersonPayload

  """Deletes a single `Person` using a unique key."""
  deletePerson(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePersonInput!
  ): DeletePersonPayload

  """Deletes a single `Person` using a unique key."""
  deletePersonByMalId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePersonByMalIdInput!
  ): DeletePersonPayload

  """Deletes a single `Producer` using its globally unique id."""
  deleteProducerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProducerByNodeIdInput!
  ): DeleteProducerPayload

  """Deletes a single `Producer` using a unique key."""
  deleteProducer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProducerInput!
  ): DeleteProducerPayload

  """Deletes a single `Producer` using a unique key."""
  deleteProducerByProducer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProducerByProducerInput!
  ): DeleteProducerPayload

  """Deletes a single `StaffRole` using its globally unique id."""
  deleteStaffRoleByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStaffRoleByNodeIdInput!
  ): DeleteStaffRolePayload

  """Deletes a single `StaffRole` using a unique key."""
  deleteStaffRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStaffRoleInput!
  ): DeleteStaffRolePayload

  """Deletes a single `StaffRole` using a unique key."""
  deleteStaffRoleByRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStaffRoleByRoleInput!
  ): DeleteStaffRolePayload

  """Deletes a single `Studio` using its globally unique id."""
  deleteStudioByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStudioByNodeIdInput!
  ): DeleteStudioPayload

  """Deletes a single `Studio` using a unique key."""
  deleteStudio(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStudioInput!
  ): DeleteStudioPayload

  """Deletes a single `Studio` using a unique key."""
  deleteStudioByStudio(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStudioByStudioInput!
  ): DeleteStudioPayload

  """Deletes a single `UserAnime` using its globally unique id."""
  deleteUserAnimeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserAnimeByNodeIdInput!
  ): DeleteUserAnimePayload

  """Deletes a single `UserAnime` using a unique key."""
  deleteUserAnime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserAnimeInput!
  ): DeleteUserAnimePayload

  """Deletes a single `UserAnimeList` using a unique key."""
  deleteUserAnimeListByAnimeListIdAndAnimeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserAnimeListByAnimeListIdAndAnimeIdInput!
  ): DeleteUserAnimeListPayload

  """Deletes a single `UserNotification` using its globally unique id."""
  deleteUserNotificationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserNotificationByNodeIdInput!
  ): DeleteUserNotificationPayload

  """Deletes a single `UserNotification` using a unique key."""
  deleteUserNotification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserNotificationInput!
  ): DeleteUserNotificationPayload

  """Deletes a single `UserWatchStatus` using its globally unique id."""
  deleteUserWatchStatusByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserWatchStatusByNodeIdInput!
  ): DeleteUserWatchStatusPayload

  """Deletes a single `UserWatchStatus` using a unique key."""
  deleteUserWatchStatus(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserWatchStatusInput!
  ): DeleteUserWatchStatusPayload

  """Deletes a single `User` using its globally unique id."""
  deleteUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserByNodeIdInput!
  ): DeleteUserPayload

  """Deletes a single `User` using a unique key."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload
  addAnimeToList(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: AddAnimeToListInput!
  ): AddAnimeToListPayload
  changeUsername(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ChangeUsernameInput!
  ): ChangeUsernamePayload
  createNewListAddAnime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateNewListAddAnimeInput!
  ): CreateNewListAddAnimePayload
  insertAnimeToUserList(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: InsertAnimeToUserListInput!
  ): InsertAnimeToUserListPayload
  insertOrUpdateAnimeUserScore(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: InsertOrUpdateAnimeUserScoreInput!
  ): InsertOrUpdateAnimeUserScorePayload
  registerUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: RegisterUserInput!
  ): RegisterUserPayload

  """Upserts a single `AlternateAnimeName`."""
  upsertAlternateAnimeName(
    where: UpsertAlternateAnimeNameWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertAlternateAnimeNameInput!
  ): UpsertAlternateAnimeNamePayload

  """Upserts a single `AnimeCharacter`."""
  upsertAnimeCharacter(
    where: UpsertAnimeCharacterWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertAnimeCharacterInput!
  ): UpsertAnimeCharacterPayload

  """Upserts a single `AnimeGenre`."""
  upsertAnimeGenre(
    where: UpsertAnimeGenreWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertAnimeGenreInput!
  ): UpsertAnimeGenrePayload

  """Upserts a single `AnimeImage`."""
  upsertAnimeImage(
    where: UpsertAnimeImageWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertAnimeImageInput!
  ): UpsertAnimeImagePayload

  """Upserts a single `AnimeLicensor`."""
  upsertAnimeLicensor(
    where: UpsertAnimeLicensorWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertAnimeLicensorInput!
  ): UpsertAnimeLicensorPayload

  """Upserts a single `AnimeList`."""
  upsertAnimeList(
    where: UpsertAnimeListWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertAnimeListInput!
  ): UpsertAnimeListPayload

  """Upserts a single `AnimeProducer`."""
  upsertAnimeProducer(
    where: UpsertAnimeProducerWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertAnimeProducerInput!
  ): UpsertAnimeProducerPayload

  """Upserts a single `AnimeStaff`."""
  upsertAnimeStaff(
    where: UpsertAnimeStaffWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertAnimeStaffInput!
  ): UpsertAnimeStaffPayload

  """Upserts a single `AnimeStreamingOn`."""
  upsertAnimeStreamingOn(
    where: UpsertAnimeStreamingOnWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertAnimeStreamingOnInput!
  ): UpsertAnimeStreamingOnPayload

  """Upserts a single `AnimeStudio`."""
  upsertAnimeStudio(
    where: UpsertAnimeStudioWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertAnimeStudioInput!
  ): UpsertAnimeStudioPayload

  """Upserts a single `AnimeUserScore`."""
  upsertAnimeUserScore(
    where: UpsertAnimeUserScoreWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertAnimeUserScoreInput!
  ): UpsertAnimeUserScorePayload

  """Upserts a single `Anime`."""
  upsertAnime(
    where: UpsertAnimeWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertAnimeInput!
  ): UpsertAnimePayload

  """Upserts a single `CharacterImage`."""
  upsertCharacterImage(
    where: UpsertCharacterImageWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertCharacterImageInput!
  ): UpsertCharacterImagePayload

  """Upserts a single `CharacterRole`."""
  upsertCharacterRole(
    where: UpsertCharacterRoleWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertCharacterRoleInput!
  ): UpsertCharacterRolePayload

  """Upserts a single `Character`."""
  upsertCharacter(
    where: UpsertCharacterWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertCharacterInput!
  ): UpsertCharacterPayload

  """Upserts a single `Genre`."""
  upsertGenre(
    where: UpsertGenreWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertGenreInput!
  ): UpsertGenrePayload

  """Upserts a single `Image`."""
  upsertImage(
    where: UpsertImageWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertImageInput!
  ): UpsertImagePayload

  """Upserts a single `Licensor`."""
  upsertLicensor(
    where: UpsertLicensorWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertLicensorInput!
  ): UpsertLicensorPayload

  """Upserts a single `PersonImage`."""
  upsertPersonImage(
    where: UpsertPersonImageWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertPersonImageInput!
  ): UpsertPersonImagePayload

  """Upserts a single `Person`."""
  upsertPerson(
    where: UpsertPersonWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertPersonInput!
  ): UpsertPersonPayload

  """Upserts a single `Producer`."""
  upsertProducer(
    where: UpsertProducerWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertProducerInput!
  ): UpsertProducerPayload

  """Upserts a single `StaffRole`."""
  upsertStaffRole(
    where: UpsertStaffRoleWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertStaffRoleInput!
  ): UpsertStaffRolePayload

  """Upserts a single `Studio`."""
  upsertStudio(
    where: UpsertStudioWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertStudioInput!
  ): UpsertStudioPayload

  """Upserts a single `UserAnime`."""
  upsertUserAnime(
    where: UpsertUserAnimeWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertUserAnimeInput!
  ): UpsertUserAnimePayload

  """Upserts a single `UserAnimeList`."""
  upsertUserAnimeList(
    where: UpsertUserAnimeListWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertUserAnimeListInput!
  ): UpsertUserAnimeListPayload

  """Upserts a single `UserNotification`."""
  upsertUserNotification(
    where: UpsertUserNotificationWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertUserNotificationInput!
  ): UpsertUserNotificationPayload

  """Upserts a single `UserWatchStatus`."""
  upsertUserWatchStatus(
    where: UpsertUserWatchStatusWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertUserWatchStatusInput!
  ): UpsertUserWatchStatusPayload

  """Upserts a single `User`."""
  upsertUser(
    where: UpsertUserWhere

    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertUserInput!
  ): UpsertUserPayload
}

"""The output of our create `AlternateAnimeName` mutation."""
type CreateAlternateAnimeNamePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AlternateAnimeName` that was created by this mutation."""
  alternateAnimeName: AlternateAnimeName

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AlternateAnimeName`."""
  anime: Anime

  """An edge for our `AlternateAnimeName`. May be used by Relay 1."""
  alternateAnimeNameEdge(
    """The method to use when ordering `AlternateAnimeName`."""
    orderBy: [AlternateAnimeNamesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AlternateAnimeNamesEdge
}

"""All input for the create `AlternateAnimeName` mutation."""
input CreateAlternateAnimeNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AlternateAnimeName` to be created by this mutation."""
  alternateAnimeName: AlternateAnimeNameInput!
}

"""An input for mutations affecting `AlternateAnimeName`"""
input AlternateAnimeNameInput {
  id: UUID
  animeId: UUID!
  name: String!
}

"""The output of our create `AnimeCharacter` mutation."""
type CreateAnimeCharacterPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeCharacter` that was created by this mutation."""
  animeCharacter: AnimeCharacter

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeCharacter`."""
  anime: Anime

  """Reads a single `Character` that is related to this `AnimeCharacter`."""
  character: Character

  """Reads a single `Person` that is related to this `AnimeCharacter`."""
  person: Person

  """
  Reads a single `CharacterRole` that is related to this `AnimeCharacter`.
  """
  characterRole: CharacterRole

  """An edge for our `AnimeCharacter`. May be used by Relay 1."""
  animeCharacterEdge(
    """The method to use when ordering `AnimeCharacter`."""
    orderBy: [AnimeCharactersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeCharactersEdge
}

"""All input for the create `AnimeCharacter` mutation."""
input CreateAnimeCharacterInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeCharacter` to be created by this mutation."""
  animeCharacter: AnimeCharacterInput!
}

"""An input for mutations affecting `AnimeCharacter`"""
input AnimeCharacterInput {
  animeId: UUID!
  characterId: UUID!
  personId: UUID!
  characterRoleId: UUID!
  language: LanguageType!
}

"""The output of our create `AnimeGenre` mutation."""
type CreateAnimeGenrePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeGenre` that was created by this mutation."""
  animeGenre: AnimeGenre

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeGenre`."""
  anime: Anime

  """Reads a single `Genre` that is related to this `AnimeGenre`."""
  genre: Genre

  """An edge for our `AnimeGenre`. May be used by Relay 1."""
  animeGenreEdge(
    """The method to use when ordering `AnimeGenre`."""
    orderBy: [AnimeGenresOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeGenresEdge
}

"""All input for the create `AnimeGenre` mutation."""
input CreateAnimeGenreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeGenre` to be created by this mutation."""
  animeGenre: AnimeGenreInput!
}

"""An input for mutations affecting `AnimeGenre`"""
input AnimeGenreInput {
  animeId: UUID!
  genreId: UUID!
}

"""The output of our create `AnimeImage` mutation."""
type CreateAnimeImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeImage` that was created by this mutation."""
  animeImage: AnimeImage

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeImage`."""
  anime: Anime

  """Reads a single `Image` that is related to this `AnimeImage`."""
  image: Image

  """An edge for our `AnimeImage`. May be used by Relay 1."""
  animeImageEdge(
    """The method to use when ordering `AnimeImage`."""
    orderBy: [AnimeImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeImagesEdge
}

"""All input for the create `AnimeImage` mutation."""
input CreateAnimeImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeImage` to be created by this mutation."""
  animeImage: AnimeImageInput!
}

"""An input for mutations affecting `AnimeImage`"""
input AnimeImageInput {
  animeId: UUID!
  imageId: UUID!
}

"""The output of our create `AnimeLicensor` mutation."""
type CreateAnimeLicensorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeLicensor` that was created by this mutation."""
  animeLicensor: AnimeLicensor

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeLicensor`."""
  anime: Anime

  """Reads a single `Licensor` that is related to this `AnimeLicensor`."""
  licensor: Licensor

  """An edge for our `AnimeLicensor`. May be used by Relay 1."""
  animeLicensorEdge(
    """The method to use when ordering `AnimeLicensor`."""
    orderBy: [AnimeLicensorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeLicensorsEdge
}

"""All input for the create `AnimeLicensor` mutation."""
input CreateAnimeLicensorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeLicensor` to be created by this mutation."""
  animeLicensor: AnimeLicensorInput!
}

"""An input for mutations affecting `AnimeLicensor`"""
input AnimeLicensorInput {
  animeId: UUID!
  licensorId: UUID!
}

"""The output of our create `AnimeList` mutation."""
type CreateAnimeListPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeList` that was created by this mutation."""
  animeList: AnimeList

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `AnimeList`."""
  user: User

  """An edge for our `AnimeList`. May be used by Relay 1."""
  animeListEdge(
    """The method to use when ordering `AnimeList`."""
    orderBy: [AnimeListsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeListsEdge
}

"""All input for the create `AnimeList` mutation."""
input CreateAnimeListInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeList` to be created by this mutation."""
  animeList: AnimeListInput!
}

"""An input for mutations affecting `AnimeList`"""
input AnimeListInput {
  id: UUID
  userId: String!
  title: String
  privacy: AnimeListPrivacy
  isDefault: Boolean
  createdAt: Datetime
}

"""The output of our create `AnimeProducer` mutation."""
type CreateAnimeProducerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeProducer` that was created by this mutation."""
  animeProducer: AnimeProducer

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeProducer`."""
  anime: Anime

  """Reads a single `Producer` that is related to this `AnimeProducer`."""
  producer: Producer

  """An edge for our `AnimeProducer`. May be used by Relay 1."""
  animeProducerEdge(
    """The method to use when ordering `AnimeProducer`."""
    orderBy: [AnimeProducersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeProducersEdge
}

"""All input for the create `AnimeProducer` mutation."""
input CreateAnimeProducerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeProducer` to be created by this mutation."""
  animeProducer: AnimeProducerInput!
}

"""An input for mutations affecting `AnimeProducer`"""
input AnimeProducerInput {
  animeId: UUID!
  producerId: UUID!
}

"""The output of our create `AnimeStaff` mutation."""
type CreateAnimeStaffPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeStaff` that was created by this mutation."""
  animeStaff: AnimeStaff

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeStaff`."""
  anime: Anime

  """Reads a single `Person` that is related to this `AnimeStaff`."""
  person: Person

  """Reads a single `StaffRole` that is related to this `AnimeStaff`."""
  staffRole: StaffRole

  """An edge for our `AnimeStaff`. May be used by Relay 1."""
  animeStaffEdge(
    """The method to use when ordering `AnimeStaff`."""
    orderBy: [AnimeStaffOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeStaffEdge
}

"""All input for the create `AnimeStaff` mutation."""
input CreateAnimeStaffInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeStaff` to be created by this mutation."""
  animeStaff: AnimeStaffInput!
}

"""An input for mutations affecting `AnimeStaff`"""
input AnimeStaffInput {
  animeId: UUID!
  personId: UUID!
  staffRoleId: UUID!
}

"""The output of our create `AnimeStreamingOn` mutation."""
type CreateAnimeStreamingOnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeStreamingOn` that was created by this mutation."""
  animeStreamingOn: AnimeStreamingOn

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeStreamingOn`."""
  anime: Anime

  """An edge for our `AnimeStreamingOn`. May be used by Relay 1."""
  animeStreamingOnEdge(
    """The method to use when ordering `AnimeStreamingOn`."""
    orderBy: [AnimeStreamingOnsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeStreamingOnsEdge
}

"""All input for the create `AnimeStreamingOn` mutation."""
input CreateAnimeStreamingOnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeStreamingOn` to be created by this mutation."""
  animeStreamingOn: AnimeStreamingOnInput!
}

"""An input for mutations affecting `AnimeStreamingOn`"""
input AnimeStreamingOnInput {
  animeId: UUID!
  streamServiceId: StreamingServices!
  url: String
}

"""The output of our create `AnimeStudio` mutation."""
type CreateAnimeStudioPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeStudio` that was created by this mutation."""
  animeStudio: AnimeStudio

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeStudio`."""
  anime: Anime

  """Reads a single `Studio` that is related to this `AnimeStudio`."""
  studio: Studio

  """An edge for our `AnimeStudio`. May be used by Relay 1."""
  animeStudioEdge(
    """The method to use when ordering `AnimeStudio`."""
    orderBy: [AnimeStudiosOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeStudiosEdge
}

"""All input for the create `AnimeStudio` mutation."""
input CreateAnimeStudioInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeStudio` to be created by this mutation."""
  animeStudio: AnimeStudioInput!
}

"""An input for mutations affecting `AnimeStudio`"""
input AnimeStudioInput {
  animeId: UUID!
  studioId: UUID!
}

"""The output of our create `AnimeUserScore` mutation."""
type CreateAnimeUserScorePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeUserScore` that was created by this mutation."""
  animeUserScore: AnimeUserScore

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeUserScore`."""
  anime: Anime

  """Reads a single `User` that is related to this `AnimeUserScore`."""
  user: User

  """An edge for our `AnimeUserScore`. May be used by Relay 1."""
  animeUserScoreEdge(
    """The method to use when ordering `AnimeUserScore`."""
    orderBy: [AnimeUserScoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeUserScoresEdge
}

"""All input for the create `AnimeUserScore` mutation."""
input CreateAnimeUserScoreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeUserScore` to be created by this mutation."""
  animeUserScore: AnimeUserScoreInput!
}

"""An input for mutations affecting `AnimeUserScore`"""
input AnimeUserScoreInput {
  animeId: UUID!
  userId: String!
  userScore: BigFloat!
}

"""The output of our create `Anime` mutation."""
type CreateAnimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Anime` that was created by this mutation."""
  anime: Anime

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Anime`. May be used by Relay 1."""
  animeEdge(
    """The method to use when ordering `Anime`."""
    orderBy: [AnimeOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeEdge
}

"""All input for the create `Anime` mutation."""
input CreateAnimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Anime` to be created by this mutation."""
  anime: AnimeInput!
}

"""An input for mutations affecting `Anime`"""
input AnimeInput {
  id: UUID
  malId: Int
  title: String!
  description: String
  numberOfEpisodes: Int
  duration: Int
  averageWatcherRating: BigFloat
  startBroadcastDatetime: Datetime
  endBroadcastDatetime: Datetime
  ageRatingType: AgeRatingTypes
  airingStatusType: AiringStatusTypes
  mediaType: MediaTypes
  sourceMaterialType: SourceMaterialTypes
  coverImage: String
  season: Season
  seasonYear: Int
  youtubeTrailerId: String
  twitterHandle: String
  officialWebsite: String
}

"""The output of our create `CharacterImage` mutation."""
type CreateCharacterImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CharacterImage` that was created by this mutation."""
  characterImage: CharacterImage

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Character` that is related to this `CharacterImage`."""
  character: Character

  """Reads a single `Image` that is related to this `CharacterImage`."""
  image: Image

  """An edge for our `CharacterImage`. May be used by Relay 1."""
  characterImageEdge(
    """The method to use when ordering `CharacterImage`."""
    orderBy: [CharacterImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CharacterImagesEdge
}

"""All input for the create `CharacterImage` mutation."""
input CreateCharacterImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CharacterImage` to be created by this mutation."""
  characterImage: CharacterImageInput!
}

"""An input for mutations affecting `CharacterImage`"""
input CharacterImageInput {
  characterId: UUID!
  imageId: UUID!
}

"""The output of our create `CharacterRole` mutation."""
type CreateCharacterRolePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CharacterRole` that was created by this mutation."""
  characterRole: CharacterRole

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `CharacterRole`. May be used by Relay 1."""
  characterRoleEdge(
    """The method to use when ordering `CharacterRole`."""
    orderBy: [CharacterRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CharacterRolesEdge
}

"""All input for the create `CharacterRole` mutation."""
input CreateCharacterRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CharacterRole` to be created by this mutation."""
  characterRole: CharacterRoleInput!
}

"""An input for mutations affecting `CharacterRole`"""
input CharacterRoleInput {
  id: UUID
  role: String!
}

"""The output of our create `Character` mutation."""
type CreateCharacterPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Character` that was created by this mutation."""
  character: Character

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Image` that is related to this `Character`."""
  characterImage: Image

  """An edge for our `Character`. May be used by Relay 1."""
  characterEdge(
    """The method to use when ordering `Character`."""
    orderBy: [CharactersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CharactersEdge
}

"""All input for the create `Character` mutation."""
input CreateCharacterInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Character` to be created by this mutation."""
  character: CharacterInput!
}

"""An input for mutations affecting `Character`"""
input CharacterInput {
  id: UUID
  malId: String
  name: String!
  description: String
  characterImageId: UUID
}

"""The output of our create `Genre` mutation."""
type CreateGenrePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Genre` that was created by this mutation."""
  genre: Genre

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Genre`. May be used by Relay 1."""
  genreEdge(
    """The method to use when ordering `Genre`."""
    orderBy: [GenresOrderBy!] = [PRIMARY_KEY_ASC]
  ): GenresEdge
}

"""All input for the create `Genre` mutation."""
input CreateGenreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Genre` to be created by this mutation."""
  genre: GenreInput!
}

"""An input for mutations affecting `Genre`"""
input GenreInput {
  id: UUID
  genre: String!
}

"""The output of our create `Image` mutation."""
type CreateImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Image` that was created by this mutation."""
  image: Image

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Image`. May be used by Relay 1."""
  imageEdge(
    """The method to use when ordering `Image`."""
    orderBy: [ImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ImagesEdge
}

"""All input for the create `Image` mutation."""
input CreateImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Image` to be created by this mutation."""
  image: ImageInput!
}

"""An input for mutations affecting `Image`"""
input ImageInput {
  id: UUID
  title: String!
  url: String!
}

"""The output of our create `Licensor` mutation."""
type CreateLicensorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Licensor` that was created by this mutation."""
  licensor: Licensor

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Licensor`. May be used by Relay 1."""
  licensorEdge(
    """The method to use when ordering `Licensor`."""
    orderBy: [LicensorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LicensorsEdge
}

"""All input for the create `Licensor` mutation."""
input CreateLicensorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Licensor` to be created by this mutation."""
  licensor: LicensorInput!
}

"""An input for mutations affecting `Licensor`"""
input LicensorInput {
  id: UUID
  licensor: String!
}

"""The output of our create `PersonImage` mutation."""
type CreatePersonImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PersonImage` that was created by this mutation."""
  personImage: PersonImage

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Person` that is related to this `PersonImage`."""
  person: Person

  """Reads a single `Image` that is related to this `PersonImage`."""
  image: Image

  """An edge for our `PersonImage`. May be used by Relay 1."""
  personImageEdge(
    """The method to use when ordering `PersonImage`."""
    orderBy: [PersonImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PersonImagesEdge
}

"""All input for the create `PersonImage` mutation."""
input CreatePersonImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `PersonImage` to be created by this mutation."""
  personImage: PersonImageInput!
}

"""An input for mutations affecting `PersonImage`"""
input PersonImageInput {
  personId: UUID!
  imageId: UUID!
}

"""The output of our create `Person` mutation."""
type CreatePersonPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Person` that was created by this mutation."""
  person: Person

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Image` that is related to this `Person`."""
  personImage: Image

  """An edge for our `Person`. May be used by Relay 1."""
  personEdge(
    """The method to use when ordering `Person`."""
    orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]
  ): PeopleEdge
}

"""All input for the create `Person` mutation."""
input CreatePersonInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Person` to be created by this mutation."""
  person: PersonInput!
}

"""An input for mutations affecting `Person`"""
input PersonInput {
  id: UUID
  malId: String
  firstName: String!
  lastName: String
  nativeName: String
  alternateNames: String
  description: String
  personImageId: UUID
}

"""The output of our create `Producer` mutation."""
type CreateProducerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Producer` that was created by this mutation."""
  producer: Producer

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Producer`. May be used by Relay 1."""
  producerEdge(
    """The method to use when ordering `Producer`."""
    orderBy: [ProducersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProducersEdge
}

"""All input for the create `Producer` mutation."""
input CreateProducerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Producer` to be created by this mutation."""
  producer: ProducerInput!
}

"""An input for mutations affecting `Producer`"""
input ProducerInput {
  id: UUID
  producer: String!
}

"""The output of our create `StaffRole` mutation."""
type CreateStaffRolePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StaffRole` that was created by this mutation."""
  staffRole: StaffRole

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `StaffRole`. May be used by Relay 1."""
  staffRoleEdge(
    """The method to use when ordering `StaffRole`."""
    orderBy: [StaffRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StaffRolesEdge
}

"""All input for the create `StaffRole` mutation."""
input CreateStaffRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `StaffRole` to be created by this mutation."""
  staffRole: StaffRoleInput!
}

"""An input for mutations affecting `StaffRole`"""
input StaffRoleInput {
  id: UUID
  role: String!
}

"""The output of our create `Studio` mutation."""
type CreateStudioPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Studio` that was created by this mutation."""
  studio: Studio

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Studio`. May be used by Relay 1."""
  studioEdge(
    """The method to use when ordering `Studio`."""
    orderBy: [StudiosOrderBy!] = [PRIMARY_KEY_ASC]
  ): StudiosEdge
}

"""All input for the create `Studio` mutation."""
input CreateStudioInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Studio` to be created by this mutation."""
  studio: StudioInput!
}

"""An input for mutations affecting `Studio`"""
input StudioInput {
  id: UUID
  studio: String!
}

"""The output of our create `UserAnime` mutation."""
type CreateUserAnimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserAnime` that was created by this mutation."""
  userAnime: UserAnime

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `UserAnime`."""
  anime: Anime

  """Reads a single `User` that is related to this `UserAnime`."""
  user: User

  """An edge for our `UserAnime`. May be used by Relay 1."""
  userAnimeEdge(
    """The method to use when ordering `UserAnime`."""
    orderBy: [UserAnimeOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserAnimeEdge
}

"""All input for the create `UserAnime` mutation."""
input CreateUserAnimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserAnime` to be created by this mutation."""
  userAnime: UserAnimeInput!
}

"""An input for mutations affecting `UserAnime`"""
input UserAnimeInput {
  animeId: UUID!
  userId: String!
}

"""The output of our create `UserAnimeList` mutation."""
type CreateUserAnimeListPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserAnimeList` that was created by this mutation."""
  userAnimeList: UserAnimeList

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `AnimeList` that is related to this `UserAnimeList`."""
  animeList: AnimeList

  """Reads a single `Anime` that is related to this `UserAnimeList`."""
  anime: Anime

  """An edge for our `UserAnimeList`. May be used by Relay 1."""
  userAnimeListEdge(
    """The method to use when ordering `UserAnimeList`."""
    orderBy: [UserAnimeListsOrderBy!] = [NATURAL]
  ): UserAnimeListsEdge
}

"""All input for the create `UserAnimeList` mutation."""
input CreateUserAnimeListInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserAnimeList` to be created by this mutation."""
  userAnimeList: UserAnimeListInput!
}

"""An input for mutations affecting `UserAnimeList`"""
input UserAnimeListInput {
  animeListId: UUID!
  animeId: UUID!
  animeIndex: String
}

"""The output of our create `UserNotification` mutation."""
type CreateUserNotificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserNotification` that was created by this mutation."""
  userNotification: UserNotification

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserNotification`."""
  user: User

  """An edge for our `UserNotification`. May be used by Relay 1."""
  userNotificationEdge(
    """The method to use when ordering `UserNotification`."""
    orderBy: [UserNotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserNotificationsEdge
}

"""All input for the create `UserNotification` mutation."""
input CreateUserNotificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserNotification` to be created by this mutation."""
  userNotification: UserNotificationInput!
}

"""An input for mutations affecting `UserNotification`"""
input UserNotificationInput {
  id: UUID
  userId: String!
  isRead: Boolean
  notificationType: NotificationType!
  createdAt: Datetime
  message: String
  entityId: UUID!
  entityImage: String
}

"""The output of our create `UserWatchStatus` mutation."""
type CreateUserWatchStatusPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserWatchStatus` that was created by this mutation."""
  userWatchStatus: UserWatchStatus

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserWatchStatus`."""
  user: User

  """Reads a single `Anime` that is related to this `UserWatchStatus`."""
  anime: Anime

  """An edge for our `UserWatchStatus`. May be used by Relay 1."""
  userWatchStatusEdge(
    """The method to use when ordering `UserWatchStatus`."""
    orderBy: [UserWatchStatusesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserWatchStatusesEdge
}

"""All input for the create `UserWatchStatus` mutation."""
input CreateUserWatchStatusInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserWatchStatus` to be created by this mutation."""
  userWatchStatus: UserWatchStatusInput!
}

"""An input for mutations affecting `UserWatchStatus`"""
input UserWatchStatusInput {
  userId: String!
  animeId: UUID!
  userEpisodesWatched: Int
  watchStatus: WatchStatusTypes
}

"""The output of our create `User` mutation."""
type CreateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was created by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the create `User` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `User` to be created by this mutation."""
  user: UserInput!
}

"""An input for mutations affecting `User`"""
input UserInput {
  id: String!
}

"""The output of our update `AlternateAnimeName` mutation."""
type UpdateAlternateAnimeNamePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AlternateAnimeName` that was updated by this mutation."""
  alternateAnimeName: AlternateAnimeName

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AlternateAnimeName`."""
  anime: Anime

  """An edge for our `AlternateAnimeName`. May be used by Relay 1."""
  alternateAnimeNameEdge(
    """The method to use when ordering `AlternateAnimeName`."""
    orderBy: [AlternateAnimeNamesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AlternateAnimeNamesEdge
}

"""All input for the `updateAlternateAnimeNameByNodeId` mutation."""
input UpdateAlternateAnimeNameByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AlternateAnimeName` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `AlternateAnimeName` being updated.
  """
  patch: AlternateAnimeNamePatch!
}

"""
Represents an update to a `AlternateAnimeName`. Fields that are set will be updated.
"""
input AlternateAnimeNamePatch {
  id: UUID
  animeId: UUID
  name: String
}

"""All input for the `updateAlternateAnimeName` mutation."""
input UpdateAlternateAnimeNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AlternateAnimeName` being updated.
  """
  patch: AlternateAnimeNamePatch!
  id: UUID!
}

"""The output of our update `AnimeCharacter` mutation."""
type UpdateAnimeCharacterPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeCharacter` that was updated by this mutation."""
  animeCharacter: AnimeCharacter

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeCharacter`."""
  anime: Anime

  """Reads a single `Character` that is related to this `AnimeCharacter`."""
  character: Character

  """Reads a single `Person` that is related to this `AnimeCharacter`."""
  person: Person

  """
  Reads a single `CharacterRole` that is related to this `AnimeCharacter`.
  """
  characterRole: CharacterRole

  """An edge for our `AnimeCharacter`. May be used by Relay 1."""
  animeCharacterEdge(
    """The method to use when ordering `AnimeCharacter`."""
    orderBy: [AnimeCharactersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeCharactersEdge
}

"""All input for the `updateAnimeCharacterByNodeId` mutation."""
input UpdateAnimeCharacterByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeCharacter` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `AnimeCharacter` being updated.
  """
  patch: AnimeCharacterPatch!
}

"""
Represents an update to a `AnimeCharacter`. Fields that are set will be updated.
"""
input AnimeCharacterPatch {
  animeId: UUID
  characterId: UUID
  personId: UUID
  characterRoleId: UUID
  language: LanguageType
}

"""All input for the `updateAnimeCharacter` mutation."""
input UpdateAnimeCharacterInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AnimeCharacter` being updated.
  """
  patch: AnimeCharacterPatch!
  animeId: UUID!
  characterId: UUID!
  personId: UUID!
  characterRoleId: UUID!
  language: LanguageType!
}

"""The output of our update `AnimeGenre` mutation."""
type UpdateAnimeGenrePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeGenre` that was updated by this mutation."""
  animeGenre: AnimeGenre

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeGenre`."""
  anime: Anime

  """Reads a single `Genre` that is related to this `AnimeGenre`."""
  genre: Genre

  """An edge for our `AnimeGenre`. May be used by Relay 1."""
  animeGenreEdge(
    """The method to use when ordering `AnimeGenre`."""
    orderBy: [AnimeGenresOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeGenresEdge
}

"""All input for the `updateAnimeGenreByNodeId` mutation."""
input UpdateAnimeGenreByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeGenre` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `AnimeGenre` being updated.
  """
  patch: AnimeGenrePatch!
}

"""
Represents an update to a `AnimeGenre`. Fields that are set will be updated.
"""
input AnimeGenrePatch {
  animeId: UUID
  genreId: UUID
}

"""All input for the `updateAnimeGenre` mutation."""
input UpdateAnimeGenreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AnimeGenre` being updated.
  """
  patch: AnimeGenrePatch!
  animeId: UUID!
  genreId: UUID!
}

"""The output of our update `AnimeImage` mutation."""
type UpdateAnimeImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeImage` that was updated by this mutation."""
  animeImage: AnimeImage

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeImage`."""
  anime: Anime

  """Reads a single `Image` that is related to this `AnimeImage`."""
  image: Image

  """An edge for our `AnimeImage`. May be used by Relay 1."""
  animeImageEdge(
    """The method to use when ordering `AnimeImage`."""
    orderBy: [AnimeImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeImagesEdge
}

"""All input for the `updateAnimeImageByNodeId` mutation."""
input UpdateAnimeImageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeImage` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `AnimeImage` being updated.
  """
  patch: AnimeImagePatch!
}

"""
Represents an update to a `AnimeImage`. Fields that are set will be updated.
"""
input AnimeImagePatch {
  animeId: UUID
  imageId: UUID
}

"""All input for the `updateAnimeImage` mutation."""
input UpdateAnimeImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AnimeImage` being updated.
  """
  patch: AnimeImagePatch!
  animeId: UUID!
  imageId: UUID!
}

"""The output of our update `AnimeLicensor` mutation."""
type UpdateAnimeLicensorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeLicensor` that was updated by this mutation."""
  animeLicensor: AnimeLicensor

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeLicensor`."""
  anime: Anime

  """Reads a single `Licensor` that is related to this `AnimeLicensor`."""
  licensor: Licensor

  """An edge for our `AnimeLicensor`. May be used by Relay 1."""
  animeLicensorEdge(
    """The method to use when ordering `AnimeLicensor`."""
    orderBy: [AnimeLicensorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeLicensorsEdge
}

"""All input for the `updateAnimeLicensorByNodeId` mutation."""
input UpdateAnimeLicensorByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeLicensor` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `AnimeLicensor` being updated.
  """
  patch: AnimeLicensorPatch!
}

"""
Represents an update to a `AnimeLicensor`. Fields that are set will be updated.
"""
input AnimeLicensorPatch {
  animeId: UUID
  licensorId: UUID
}

"""All input for the `updateAnimeLicensor` mutation."""
input UpdateAnimeLicensorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AnimeLicensor` being updated.
  """
  patch: AnimeLicensorPatch!
  animeId: UUID!
  licensorId: UUID!
}

"""The output of our update `AnimeList` mutation."""
type UpdateAnimeListPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeList` that was updated by this mutation."""
  animeList: AnimeList

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `AnimeList`."""
  user: User

  """An edge for our `AnimeList`. May be used by Relay 1."""
  animeListEdge(
    """The method to use when ordering `AnimeList`."""
    orderBy: [AnimeListsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeListsEdge
}

"""All input for the `updateAnimeListByNodeId` mutation."""
input UpdateAnimeListByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeList` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `AnimeList` being updated.
  """
  patch: AnimeListPatch!
}

"""
Represents an update to a `AnimeList`. Fields that are set will be updated.
"""
input AnimeListPatch {
  id: UUID
  userId: String
  title: String
  privacy: AnimeListPrivacy
  isDefault: Boolean
  createdAt: Datetime
}

"""All input for the `updateAnimeList` mutation."""
input UpdateAnimeListInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AnimeList` being updated.
  """
  patch: AnimeListPatch!
  id: UUID!
}

"""The output of our update `AnimeProducer` mutation."""
type UpdateAnimeProducerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeProducer` that was updated by this mutation."""
  animeProducer: AnimeProducer

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeProducer`."""
  anime: Anime

  """Reads a single `Producer` that is related to this `AnimeProducer`."""
  producer: Producer

  """An edge for our `AnimeProducer`. May be used by Relay 1."""
  animeProducerEdge(
    """The method to use when ordering `AnimeProducer`."""
    orderBy: [AnimeProducersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeProducersEdge
}

"""All input for the `updateAnimeProducerByNodeId` mutation."""
input UpdateAnimeProducerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeProducer` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `AnimeProducer` being updated.
  """
  patch: AnimeProducerPatch!
}

"""
Represents an update to a `AnimeProducer`. Fields that are set will be updated.
"""
input AnimeProducerPatch {
  animeId: UUID
  producerId: UUID
}

"""All input for the `updateAnimeProducer` mutation."""
input UpdateAnimeProducerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AnimeProducer` being updated.
  """
  patch: AnimeProducerPatch!
  animeId: UUID!
  producerId: UUID!
}

"""The output of our update `AnimeStaff` mutation."""
type UpdateAnimeStaffPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeStaff` that was updated by this mutation."""
  animeStaff: AnimeStaff

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeStaff`."""
  anime: Anime

  """Reads a single `Person` that is related to this `AnimeStaff`."""
  person: Person

  """Reads a single `StaffRole` that is related to this `AnimeStaff`."""
  staffRole: StaffRole

  """An edge for our `AnimeStaff`. May be used by Relay 1."""
  animeStaffEdge(
    """The method to use when ordering `AnimeStaff`."""
    orderBy: [AnimeStaffOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeStaffEdge
}

"""All input for the `updateAnimeStaffByNodeId` mutation."""
input UpdateAnimeStaffByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeStaff` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `AnimeStaff` being updated.
  """
  patch: AnimeStaffPatch!
}

"""
Represents an update to a `AnimeStaff`. Fields that are set will be updated.
"""
input AnimeStaffPatch {
  animeId: UUID
  personId: UUID
  staffRoleId: UUID
}

"""All input for the `updateAnimeStaff` mutation."""
input UpdateAnimeStaffInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AnimeStaff` being updated.
  """
  patch: AnimeStaffPatch!
  animeId: UUID!
  personId: UUID!
  staffRoleId: UUID!
}

"""The output of our update `AnimeStreamingOn` mutation."""
type UpdateAnimeStreamingOnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeStreamingOn` that was updated by this mutation."""
  animeStreamingOn: AnimeStreamingOn

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeStreamingOn`."""
  anime: Anime

  """An edge for our `AnimeStreamingOn`. May be used by Relay 1."""
  animeStreamingOnEdge(
    """The method to use when ordering `AnimeStreamingOn`."""
    orderBy: [AnimeStreamingOnsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeStreamingOnsEdge
}

"""All input for the `updateAnimeStreamingOnByNodeId` mutation."""
input UpdateAnimeStreamingOnByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeStreamingOn` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `AnimeStreamingOn` being updated.
  """
  patch: AnimeStreamingOnPatch!
}

"""
Represents an update to a `AnimeStreamingOn`. Fields that are set will be updated.
"""
input AnimeStreamingOnPatch {
  animeId: UUID
  streamServiceId: StreamingServices
  url: String
}

"""All input for the `updateAnimeStreamingOn` mutation."""
input UpdateAnimeStreamingOnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AnimeStreamingOn` being updated.
  """
  patch: AnimeStreamingOnPatch!
  animeId: UUID!
  streamServiceId: StreamingServices!
}

"""The output of our update `AnimeStudio` mutation."""
type UpdateAnimeStudioPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeStudio` that was updated by this mutation."""
  animeStudio: AnimeStudio

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeStudio`."""
  anime: Anime

  """Reads a single `Studio` that is related to this `AnimeStudio`."""
  studio: Studio

  """An edge for our `AnimeStudio`. May be used by Relay 1."""
  animeStudioEdge(
    """The method to use when ordering `AnimeStudio`."""
    orderBy: [AnimeStudiosOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeStudiosEdge
}

"""All input for the `updateAnimeStudioByNodeId` mutation."""
input UpdateAnimeStudioByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeStudio` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `AnimeStudio` being updated.
  """
  patch: AnimeStudioPatch!
}

"""
Represents an update to a `AnimeStudio`. Fields that are set will be updated.
"""
input AnimeStudioPatch {
  animeId: UUID
  studioId: UUID
}

"""All input for the `updateAnimeStudio` mutation."""
input UpdateAnimeStudioInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AnimeStudio` being updated.
  """
  patch: AnimeStudioPatch!
  animeId: UUID!
  studioId: UUID!
}

"""The output of our update `AnimeUserScore` mutation."""
type UpdateAnimeUserScorePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeUserScore` that was updated by this mutation."""
  animeUserScore: AnimeUserScore

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeUserScore`."""
  anime: Anime

  """Reads a single `User` that is related to this `AnimeUserScore`."""
  user: User

  """An edge for our `AnimeUserScore`. May be used by Relay 1."""
  animeUserScoreEdge(
    """The method to use when ordering `AnimeUserScore`."""
    orderBy: [AnimeUserScoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeUserScoresEdge
}

"""All input for the `updateAnimeUserScoreByNodeId` mutation."""
input UpdateAnimeUserScoreByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeUserScore` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `AnimeUserScore` being updated.
  """
  patch: AnimeUserScorePatch!
}

"""
Represents an update to a `AnimeUserScore`. Fields that are set will be updated.
"""
input AnimeUserScorePatch {
  animeId: UUID
  userId: String
  userScore: BigFloat
}

"""All input for the `updateAnimeUserScore` mutation."""
input UpdateAnimeUserScoreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AnimeUserScore` being updated.
  """
  patch: AnimeUserScorePatch!
  animeId: UUID!
  userId: String!
}

"""The output of our update `Anime` mutation."""
type UpdateAnimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Anime` that was updated by this mutation."""
  anime: Anime

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Anime`. May be used by Relay 1."""
  animeEdge(
    """The method to use when ordering `Anime`."""
    orderBy: [AnimeOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeEdge
}

"""All input for the `updateAnimeByNodeId` mutation."""
input UpdateAnimeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Anime` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Anime` being updated.
  """
  patch: AnimePatch!
}

"""
Represents an update to a `Anime`. Fields that are set will be updated.
"""
input AnimePatch {
  id: UUID
  malId: Int
  title: String
  description: String
  numberOfEpisodes: Int
  duration: Int
  averageWatcherRating: BigFloat
  startBroadcastDatetime: Datetime
  endBroadcastDatetime: Datetime
  ageRatingType: AgeRatingTypes
  airingStatusType: AiringStatusTypes
  mediaType: MediaTypes
  sourceMaterialType: SourceMaterialTypes
  coverImage: String
  season: Season
  seasonYear: Int
  youtubeTrailerId: String
  twitterHandle: String
  officialWebsite: String
}

"""All input for the `updateAnime` mutation."""
input UpdateAnimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Anime` being updated.
  """
  patch: AnimePatch!
  id: UUID!
}

"""All input for the `updateAnimeByMalId` mutation."""
input UpdateAnimeByMalIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Anime` being updated.
  """
  patch: AnimePatch!
  malId: Int!
}

"""The output of our update `CharacterImage` mutation."""
type UpdateCharacterImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CharacterImage` that was updated by this mutation."""
  characterImage: CharacterImage

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Character` that is related to this `CharacterImage`."""
  character: Character

  """Reads a single `Image` that is related to this `CharacterImage`."""
  image: Image

  """An edge for our `CharacterImage`. May be used by Relay 1."""
  characterImageEdge(
    """The method to use when ordering `CharacterImage`."""
    orderBy: [CharacterImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CharacterImagesEdge
}

"""All input for the `updateCharacterImageByNodeId` mutation."""
input UpdateCharacterImageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CharacterImage` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CharacterImage` being updated.
  """
  patch: CharacterImagePatch!
}

"""
Represents an update to a `CharacterImage`. Fields that are set will be updated.
"""
input CharacterImagePatch {
  characterId: UUID
  imageId: UUID
}

"""All input for the `updateCharacterImage` mutation."""
input UpdateCharacterImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `CharacterImage` being updated.
  """
  patch: CharacterImagePatch!
  characterId: UUID!
  imageId: UUID!
}

"""The output of our update `CharacterRole` mutation."""
type UpdateCharacterRolePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CharacterRole` that was updated by this mutation."""
  characterRole: CharacterRole

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `CharacterRole`. May be used by Relay 1."""
  characterRoleEdge(
    """The method to use when ordering `CharacterRole`."""
    orderBy: [CharacterRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CharacterRolesEdge
}

"""All input for the `updateCharacterRoleByNodeId` mutation."""
input UpdateCharacterRoleByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CharacterRole` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CharacterRole` being updated.
  """
  patch: CharacterRolePatch!
}

"""
Represents an update to a `CharacterRole`. Fields that are set will be updated.
"""
input CharacterRolePatch {
  id: UUID
  role: String
}

"""All input for the `updateCharacterRole` mutation."""
input UpdateCharacterRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `CharacterRole` being updated.
  """
  patch: CharacterRolePatch!
  id: UUID!
}

"""All input for the `updateCharacterRoleByRole` mutation."""
input UpdateCharacterRoleByRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `CharacterRole` being updated.
  """
  patch: CharacterRolePatch!
  role: String!
}

"""The output of our update `Character` mutation."""
type UpdateCharacterPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Character` that was updated by this mutation."""
  character: Character

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Image` that is related to this `Character`."""
  characterImage: Image

  """An edge for our `Character`. May be used by Relay 1."""
  characterEdge(
    """The method to use when ordering `Character`."""
    orderBy: [CharactersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CharactersEdge
}

"""All input for the `updateCharacterByNodeId` mutation."""
input UpdateCharacterByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Character` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Character` being updated.
  """
  patch: CharacterPatch!
}

"""
Represents an update to a `Character`. Fields that are set will be updated.
"""
input CharacterPatch {
  id: UUID
  malId: String
  name: String
  description: String
  characterImageId: UUID
}

"""All input for the `updateCharacter` mutation."""
input UpdateCharacterInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Character` being updated.
  """
  patch: CharacterPatch!
  id: UUID!
}

"""All input for the `updateCharacterByMalId` mutation."""
input UpdateCharacterByMalIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Character` being updated.
  """
  patch: CharacterPatch!
  malId: String!
}

"""The output of our update `Genre` mutation."""
type UpdateGenrePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Genre` that was updated by this mutation."""
  genre: Genre

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Genre`. May be used by Relay 1."""
  genreEdge(
    """The method to use when ordering `Genre`."""
    orderBy: [GenresOrderBy!] = [PRIMARY_KEY_ASC]
  ): GenresEdge
}

"""All input for the `updateGenreByNodeId` mutation."""
input UpdateGenreByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Genre` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Genre` being updated.
  """
  patch: GenrePatch!
}

"""
Represents an update to a `Genre`. Fields that are set will be updated.
"""
input GenrePatch {
  id: UUID
  genre: String
}

"""All input for the `updateGenre` mutation."""
input UpdateGenreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Genre` being updated.
  """
  patch: GenrePatch!
  id: UUID!
}

"""All input for the `updateGenreByGenre` mutation."""
input UpdateGenreByGenreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Genre` being updated.
  """
  patch: GenrePatch!
  genre: String!
}

"""The output of our update `Image` mutation."""
type UpdateImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Image` that was updated by this mutation."""
  image: Image

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Image`. May be used by Relay 1."""
  imageEdge(
    """The method to use when ordering `Image`."""
    orderBy: [ImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ImagesEdge
}

"""All input for the `updateImageByNodeId` mutation."""
input UpdateImageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Image` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Image` being updated.
  """
  patch: ImagePatch!
}

"""
Represents an update to a `Image`. Fields that are set will be updated.
"""
input ImagePatch {
  id: UUID
  title: String
  url: String
}

"""All input for the `updateImage` mutation."""
input UpdateImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Image` being updated.
  """
  patch: ImagePatch!
  id: UUID!
}

"""The output of our update `Licensor` mutation."""
type UpdateLicensorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Licensor` that was updated by this mutation."""
  licensor: Licensor

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Licensor`. May be used by Relay 1."""
  licensorEdge(
    """The method to use when ordering `Licensor`."""
    orderBy: [LicensorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LicensorsEdge
}

"""All input for the `updateLicensorByNodeId` mutation."""
input UpdateLicensorByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Licensor` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Licensor` being updated.
  """
  patch: LicensorPatch!
}

"""
Represents an update to a `Licensor`. Fields that are set will be updated.
"""
input LicensorPatch {
  id: UUID
  licensor: String
}

"""All input for the `updateLicensor` mutation."""
input UpdateLicensorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Licensor` being updated.
  """
  patch: LicensorPatch!
  id: UUID!
}

"""All input for the `updateLicensorByLicensor` mutation."""
input UpdateLicensorByLicensorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Licensor` being updated.
  """
  patch: LicensorPatch!
  licensor: String!
}

"""The output of our update `PersonImage` mutation."""
type UpdatePersonImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PersonImage` that was updated by this mutation."""
  personImage: PersonImage

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Person` that is related to this `PersonImage`."""
  person: Person

  """Reads a single `Image` that is related to this `PersonImage`."""
  image: Image

  """An edge for our `PersonImage`. May be used by Relay 1."""
  personImageEdge(
    """The method to use when ordering `PersonImage`."""
    orderBy: [PersonImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PersonImagesEdge
}

"""All input for the `updatePersonImageByNodeId` mutation."""
input UpdatePersonImageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PersonImage` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `PersonImage` being updated.
  """
  patch: PersonImagePatch!
}

"""
Represents an update to a `PersonImage`. Fields that are set will be updated.
"""
input PersonImagePatch {
  personId: UUID
  imageId: UUID
}

"""All input for the `updatePersonImage` mutation."""
input UpdatePersonImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PersonImage` being updated.
  """
  patch: PersonImagePatch!
  personId: UUID!
  imageId: UUID!
}

"""The output of our update `Person` mutation."""
type UpdatePersonPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Person` that was updated by this mutation."""
  person: Person

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Image` that is related to this `Person`."""
  personImage: Image

  """An edge for our `Person`. May be used by Relay 1."""
  personEdge(
    """The method to use when ordering `Person`."""
    orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]
  ): PeopleEdge
}

"""All input for the `updatePersonByNodeId` mutation."""
input UpdatePersonByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Person` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Person` being updated.
  """
  patch: PersonPatch!
}

"""
Represents an update to a `Person`. Fields that are set will be updated.
"""
input PersonPatch {
  id: UUID
  malId: String
  firstName: String
  lastName: String
  nativeName: String
  alternateNames: String
  description: String
  personImageId: UUID
}

"""All input for the `updatePerson` mutation."""
input UpdatePersonInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Person` being updated.
  """
  patch: PersonPatch!
  id: UUID!
}

"""All input for the `updatePersonByMalId` mutation."""
input UpdatePersonByMalIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Person` being updated.
  """
  patch: PersonPatch!
  malId: String!
}

"""The output of our update `Producer` mutation."""
type UpdateProducerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Producer` that was updated by this mutation."""
  producer: Producer

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Producer`. May be used by Relay 1."""
  producerEdge(
    """The method to use when ordering `Producer`."""
    orderBy: [ProducersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProducersEdge
}

"""All input for the `updateProducerByNodeId` mutation."""
input UpdateProducerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Producer` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Producer` being updated.
  """
  patch: ProducerPatch!
}

"""
Represents an update to a `Producer`. Fields that are set will be updated.
"""
input ProducerPatch {
  id: UUID
  producer: String
}

"""All input for the `updateProducer` mutation."""
input UpdateProducerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Producer` being updated.
  """
  patch: ProducerPatch!
  id: UUID!
}

"""All input for the `updateProducerByProducer` mutation."""
input UpdateProducerByProducerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Producer` being updated.
  """
  patch: ProducerPatch!
  producer: String!
}

"""The output of our update `StaffRole` mutation."""
type UpdateStaffRolePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StaffRole` that was updated by this mutation."""
  staffRole: StaffRole

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `StaffRole`. May be used by Relay 1."""
  staffRoleEdge(
    """The method to use when ordering `StaffRole`."""
    orderBy: [StaffRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StaffRolesEdge
}

"""All input for the `updateStaffRoleByNodeId` mutation."""
input UpdateStaffRoleByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `StaffRole` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `StaffRole` being updated.
  """
  patch: StaffRolePatch!
}

"""
Represents an update to a `StaffRole`. Fields that are set will be updated.
"""
input StaffRolePatch {
  id: UUID
  role: String
}

"""All input for the `updateStaffRole` mutation."""
input UpdateStaffRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `StaffRole` being updated.
  """
  patch: StaffRolePatch!
  id: UUID!
}

"""All input for the `updateStaffRoleByRole` mutation."""
input UpdateStaffRoleByRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `StaffRole` being updated.
  """
  patch: StaffRolePatch!
  role: String!
}

"""The output of our update `Studio` mutation."""
type UpdateStudioPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Studio` that was updated by this mutation."""
  studio: Studio

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Studio`. May be used by Relay 1."""
  studioEdge(
    """The method to use when ordering `Studio`."""
    orderBy: [StudiosOrderBy!] = [PRIMARY_KEY_ASC]
  ): StudiosEdge
}

"""All input for the `updateStudioByNodeId` mutation."""
input UpdateStudioByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Studio` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Studio` being updated.
  """
  patch: StudioPatch!
}

"""
Represents an update to a `Studio`. Fields that are set will be updated.
"""
input StudioPatch {
  id: UUID
  studio: String
}

"""All input for the `updateStudio` mutation."""
input UpdateStudioInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Studio` being updated.
  """
  patch: StudioPatch!
  id: UUID!
}

"""All input for the `updateStudioByStudio` mutation."""
input UpdateStudioByStudioInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Studio` being updated.
  """
  patch: StudioPatch!
  studio: String!
}

"""The output of our update `UserAnime` mutation."""
type UpdateUserAnimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserAnime` that was updated by this mutation."""
  userAnime: UserAnime

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `UserAnime`."""
  anime: Anime

  """Reads a single `User` that is related to this `UserAnime`."""
  user: User

  """An edge for our `UserAnime`. May be used by Relay 1."""
  userAnimeEdge(
    """The method to use when ordering `UserAnime`."""
    orderBy: [UserAnimeOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserAnimeEdge
}

"""All input for the `updateUserAnimeByNodeId` mutation."""
input UpdateUserAnimeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserAnime` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `UserAnime` being updated.
  """
  patch: UserAnimePatch!
}

"""
Represents an update to a `UserAnime`. Fields that are set will be updated.
"""
input UserAnimePatch {
  animeId: UUID
  userId: String
}

"""All input for the `updateUserAnime` mutation."""
input UpdateUserAnimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserAnime` being updated.
  """
  patch: UserAnimePatch!
  animeId: UUID!
  userId: String!
}

"""The output of our update `UserAnimeList` mutation."""
type UpdateUserAnimeListPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserAnimeList` that was updated by this mutation."""
  userAnimeList: UserAnimeList

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `AnimeList` that is related to this `UserAnimeList`."""
  animeList: AnimeList

  """Reads a single `Anime` that is related to this `UserAnimeList`."""
  anime: Anime

  """An edge for our `UserAnimeList`. May be used by Relay 1."""
  userAnimeListEdge(
    """The method to use when ordering `UserAnimeList`."""
    orderBy: [UserAnimeListsOrderBy!] = [NATURAL]
  ): UserAnimeListsEdge
}

"""
All input for the `updateUserAnimeListByAnimeListIdAndAnimeId` mutation.
"""
input UpdateUserAnimeListByAnimeListIdAndAnimeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserAnimeList` being updated.
  """
  patch: UserAnimeListPatch!
  animeListId: UUID!
  animeId: UUID!
}

"""
Represents an update to a `UserAnimeList`. Fields that are set will be updated.
"""
input UserAnimeListPatch {
  animeListId: UUID
  animeId: UUID
  animeIndex: String
}

"""The output of our update `UserNotification` mutation."""
type UpdateUserNotificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserNotification` that was updated by this mutation."""
  userNotification: UserNotification

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserNotification`."""
  user: User

  """An edge for our `UserNotification`. May be used by Relay 1."""
  userNotificationEdge(
    """The method to use when ordering `UserNotification`."""
    orderBy: [UserNotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserNotificationsEdge
}

"""All input for the `updateUserNotificationByNodeId` mutation."""
input UpdateUserNotificationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserNotification` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `UserNotification` being updated.
  """
  patch: UserNotificationPatch!
}

"""
Represents an update to a `UserNotification`. Fields that are set will be updated.
"""
input UserNotificationPatch {
  id: UUID
  userId: String
  isRead: Boolean
  notificationType: NotificationType
  createdAt: Datetime
  message: String
  entityId: UUID
  entityImage: String
}

"""All input for the `updateUserNotification` mutation."""
input UpdateUserNotificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserNotification` being updated.
  """
  patch: UserNotificationPatch!
  id: UUID!
}

"""The output of our update `UserWatchStatus` mutation."""
type UpdateUserWatchStatusPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserWatchStatus` that was updated by this mutation."""
  userWatchStatus: UserWatchStatus

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserWatchStatus`."""
  user: User

  """Reads a single `Anime` that is related to this `UserWatchStatus`."""
  anime: Anime

  """An edge for our `UserWatchStatus`. May be used by Relay 1."""
  userWatchStatusEdge(
    """The method to use when ordering `UserWatchStatus`."""
    orderBy: [UserWatchStatusesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserWatchStatusesEdge
}

"""All input for the `updateUserWatchStatusByNodeId` mutation."""
input UpdateUserWatchStatusByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserWatchStatus` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `UserWatchStatus` being updated.
  """
  patch: UserWatchStatusPatch!
}

"""
Represents an update to a `UserWatchStatus`. Fields that are set will be updated.
"""
input UserWatchStatusPatch {
  userId: String
  animeId: UUID
  userEpisodesWatched: Int
  watchStatus: WatchStatusTypes
}

"""All input for the `updateUserWatchStatus` mutation."""
input UpdateUserWatchStatusInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserWatchStatus` being updated.
  """
  patch: UserWatchStatusPatch!
  userId: String!
  animeId: UUID!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was updated by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `updateUserByNodeId` mutation."""
input UpdateUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""Represents an update to a `User`. Fields that are set will be updated."""
input UserPatch {
  id: String
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
  id: String!
}

"""The output of our delete `AlternateAnimeName` mutation."""
type DeleteAlternateAnimeNamePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AlternateAnimeName` that was deleted by this mutation."""
  alternateAnimeName: AlternateAnimeName
  deletedAlternateAnimeNameNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AlternateAnimeName`."""
  anime: Anime

  """An edge for our `AlternateAnimeName`. May be used by Relay 1."""
  alternateAnimeNameEdge(
    """The method to use when ordering `AlternateAnimeName`."""
    orderBy: [AlternateAnimeNamesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AlternateAnimeNamesEdge
}

"""All input for the `deleteAlternateAnimeNameByNodeId` mutation."""
input DeleteAlternateAnimeNameByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AlternateAnimeName` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAlternateAnimeName` mutation."""
input DeleteAlternateAnimeNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `AnimeCharacter` mutation."""
type DeleteAnimeCharacterPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeCharacter` that was deleted by this mutation."""
  animeCharacter: AnimeCharacter
  deletedAnimeCharacterNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeCharacter`."""
  anime: Anime

  """Reads a single `Character` that is related to this `AnimeCharacter`."""
  character: Character

  """Reads a single `Person` that is related to this `AnimeCharacter`."""
  person: Person

  """
  Reads a single `CharacterRole` that is related to this `AnimeCharacter`.
  """
  characterRole: CharacterRole

  """An edge for our `AnimeCharacter`. May be used by Relay 1."""
  animeCharacterEdge(
    """The method to use when ordering `AnimeCharacter`."""
    orderBy: [AnimeCharactersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeCharactersEdge
}

"""All input for the `deleteAnimeCharacterByNodeId` mutation."""
input DeleteAnimeCharacterByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeCharacter` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAnimeCharacter` mutation."""
input DeleteAnimeCharacterInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  animeId: UUID!
  characterId: UUID!
  personId: UUID!
  characterRoleId: UUID!
  language: LanguageType!
}

"""The output of our delete `AnimeGenre` mutation."""
type DeleteAnimeGenrePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeGenre` that was deleted by this mutation."""
  animeGenre: AnimeGenre
  deletedAnimeGenreNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeGenre`."""
  anime: Anime

  """Reads a single `Genre` that is related to this `AnimeGenre`."""
  genre: Genre

  """An edge for our `AnimeGenre`. May be used by Relay 1."""
  animeGenreEdge(
    """The method to use when ordering `AnimeGenre`."""
    orderBy: [AnimeGenresOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeGenresEdge
}

"""All input for the `deleteAnimeGenreByNodeId` mutation."""
input DeleteAnimeGenreByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeGenre` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAnimeGenre` mutation."""
input DeleteAnimeGenreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  animeId: UUID!
  genreId: UUID!
}

"""The output of our delete `AnimeImage` mutation."""
type DeleteAnimeImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeImage` that was deleted by this mutation."""
  animeImage: AnimeImage
  deletedAnimeImageNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeImage`."""
  anime: Anime

  """Reads a single `Image` that is related to this `AnimeImage`."""
  image: Image

  """An edge for our `AnimeImage`. May be used by Relay 1."""
  animeImageEdge(
    """The method to use when ordering `AnimeImage`."""
    orderBy: [AnimeImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeImagesEdge
}

"""All input for the `deleteAnimeImageByNodeId` mutation."""
input DeleteAnimeImageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeImage` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAnimeImage` mutation."""
input DeleteAnimeImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  animeId: UUID!
  imageId: UUID!
}

"""The output of our delete `AnimeLicensor` mutation."""
type DeleteAnimeLicensorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeLicensor` that was deleted by this mutation."""
  animeLicensor: AnimeLicensor
  deletedAnimeLicensorNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeLicensor`."""
  anime: Anime

  """Reads a single `Licensor` that is related to this `AnimeLicensor`."""
  licensor: Licensor

  """An edge for our `AnimeLicensor`. May be used by Relay 1."""
  animeLicensorEdge(
    """The method to use when ordering `AnimeLicensor`."""
    orderBy: [AnimeLicensorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeLicensorsEdge
}

"""All input for the `deleteAnimeLicensorByNodeId` mutation."""
input DeleteAnimeLicensorByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeLicensor` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAnimeLicensor` mutation."""
input DeleteAnimeLicensorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  animeId: UUID!
  licensorId: UUID!
}

"""The output of our delete `AnimeList` mutation."""
type DeleteAnimeListPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeList` that was deleted by this mutation."""
  animeList: AnimeList
  deletedAnimeListNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `AnimeList`."""
  user: User

  """An edge for our `AnimeList`. May be used by Relay 1."""
  animeListEdge(
    """The method to use when ordering `AnimeList`."""
    orderBy: [AnimeListsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeListsEdge
}

"""All input for the `deleteAnimeListByNodeId` mutation."""
input DeleteAnimeListByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeList` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAnimeList` mutation."""
input DeleteAnimeListInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `AnimeProducer` mutation."""
type DeleteAnimeProducerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeProducer` that was deleted by this mutation."""
  animeProducer: AnimeProducer
  deletedAnimeProducerNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeProducer`."""
  anime: Anime

  """Reads a single `Producer` that is related to this `AnimeProducer`."""
  producer: Producer

  """An edge for our `AnimeProducer`. May be used by Relay 1."""
  animeProducerEdge(
    """The method to use when ordering `AnimeProducer`."""
    orderBy: [AnimeProducersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeProducersEdge
}

"""All input for the `deleteAnimeProducerByNodeId` mutation."""
input DeleteAnimeProducerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeProducer` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAnimeProducer` mutation."""
input DeleteAnimeProducerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  animeId: UUID!
  producerId: UUID!
}

"""The output of our delete `AnimeStaff` mutation."""
type DeleteAnimeStaffPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeStaff` that was deleted by this mutation."""
  animeStaff: AnimeStaff
  deletedAnimeStaffNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeStaff`."""
  anime: Anime

  """Reads a single `Person` that is related to this `AnimeStaff`."""
  person: Person

  """Reads a single `StaffRole` that is related to this `AnimeStaff`."""
  staffRole: StaffRole

  """An edge for our `AnimeStaff`. May be used by Relay 1."""
  animeStaffEdge(
    """The method to use when ordering `AnimeStaff`."""
    orderBy: [AnimeStaffOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeStaffEdge
}

"""All input for the `deleteAnimeStaffByNodeId` mutation."""
input DeleteAnimeStaffByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeStaff` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAnimeStaff` mutation."""
input DeleteAnimeStaffInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  animeId: UUID!
  personId: UUID!
  staffRoleId: UUID!
}

"""The output of our delete `AnimeStreamingOn` mutation."""
type DeleteAnimeStreamingOnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeStreamingOn` that was deleted by this mutation."""
  animeStreamingOn: AnimeStreamingOn
  deletedAnimeStreamingOnNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeStreamingOn`."""
  anime: Anime

  """An edge for our `AnimeStreamingOn`. May be used by Relay 1."""
  animeStreamingOnEdge(
    """The method to use when ordering `AnimeStreamingOn`."""
    orderBy: [AnimeStreamingOnsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeStreamingOnsEdge
}

"""All input for the `deleteAnimeStreamingOnByNodeId` mutation."""
input DeleteAnimeStreamingOnByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeStreamingOn` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAnimeStreamingOn` mutation."""
input DeleteAnimeStreamingOnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  animeId: UUID!
  streamServiceId: StreamingServices!
}

"""The output of our delete `AnimeStudio` mutation."""
type DeleteAnimeStudioPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeStudio` that was deleted by this mutation."""
  animeStudio: AnimeStudio
  deletedAnimeStudioNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeStudio`."""
  anime: Anime

  """Reads a single `Studio` that is related to this `AnimeStudio`."""
  studio: Studio

  """An edge for our `AnimeStudio`. May be used by Relay 1."""
  animeStudioEdge(
    """The method to use when ordering `AnimeStudio`."""
    orderBy: [AnimeStudiosOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeStudiosEdge
}

"""All input for the `deleteAnimeStudioByNodeId` mutation."""
input DeleteAnimeStudioByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeStudio` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAnimeStudio` mutation."""
input DeleteAnimeStudioInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  animeId: UUID!
  studioId: UUID!
}

"""The output of our delete `AnimeUserScore` mutation."""
type DeleteAnimeUserScorePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeUserScore` that was deleted by this mutation."""
  animeUserScore: AnimeUserScore
  deletedAnimeUserScoreNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeUserScore`."""
  anime: Anime

  """Reads a single `User` that is related to this `AnimeUserScore`."""
  user: User

  """An edge for our `AnimeUserScore`. May be used by Relay 1."""
  animeUserScoreEdge(
    """The method to use when ordering `AnimeUserScore`."""
    orderBy: [AnimeUserScoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeUserScoresEdge
}

"""All input for the `deleteAnimeUserScoreByNodeId` mutation."""
input DeleteAnimeUserScoreByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AnimeUserScore` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAnimeUserScore` mutation."""
input DeleteAnimeUserScoreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  animeId: UUID!
  userId: String!
}

"""The output of our delete `Anime` mutation."""
type DeleteAnimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Anime` that was deleted by this mutation."""
  anime: Anime
  deletedAnimeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Anime`. May be used by Relay 1."""
  animeEdge(
    """The method to use when ordering `Anime`."""
    orderBy: [AnimeOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeEdge
}

"""All input for the `deleteAnimeByNodeId` mutation."""
input DeleteAnimeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Anime` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAnime` mutation."""
input DeleteAnimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""All input for the `deleteAnimeByMalId` mutation."""
input DeleteAnimeByMalIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  malId: Int!
}

"""The output of our delete `CharacterImage` mutation."""
type DeleteCharacterImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CharacterImage` that was deleted by this mutation."""
  characterImage: CharacterImage
  deletedCharacterImageNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Character` that is related to this `CharacterImage`."""
  character: Character

  """Reads a single `Image` that is related to this `CharacterImage`."""
  image: Image

  """An edge for our `CharacterImage`. May be used by Relay 1."""
  characterImageEdge(
    """The method to use when ordering `CharacterImage`."""
    orderBy: [CharacterImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CharacterImagesEdge
}

"""All input for the `deleteCharacterImageByNodeId` mutation."""
input DeleteCharacterImageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CharacterImage` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCharacterImage` mutation."""
input DeleteCharacterImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  characterId: UUID!
  imageId: UUID!
}

"""The output of our delete `CharacterRole` mutation."""
type DeleteCharacterRolePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CharacterRole` that was deleted by this mutation."""
  characterRole: CharacterRole
  deletedCharacterRoleNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `CharacterRole`. May be used by Relay 1."""
  characterRoleEdge(
    """The method to use when ordering `CharacterRole`."""
    orderBy: [CharacterRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CharacterRolesEdge
}

"""All input for the `deleteCharacterRoleByNodeId` mutation."""
input DeleteCharacterRoleByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CharacterRole` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCharacterRole` mutation."""
input DeleteCharacterRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""All input for the `deleteCharacterRoleByRole` mutation."""
input DeleteCharacterRoleByRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  role: String!
}

"""The output of our delete `Character` mutation."""
type DeleteCharacterPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Character` that was deleted by this mutation."""
  character: Character
  deletedCharacterNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Image` that is related to this `Character`."""
  characterImage: Image

  """An edge for our `Character`. May be used by Relay 1."""
  characterEdge(
    """The method to use when ordering `Character`."""
    orderBy: [CharactersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CharactersEdge
}

"""All input for the `deleteCharacterByNodeId` mutation."""
input DeleteCharacterByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Character` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCharacter` mutation."""
input DeleteCharacterInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""All input for the `deleteCharacterByMalId` mutation."""
input DeleteCharacterByMalIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  malId: String!
}

"""The output of our delete `Genre` mutation."""
type DeleteGenrePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Genre` that was deleted by this mutation."""
  genre: Genre
  deletedGenreNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Genre`. May be used by Relay 1."""
  genreEdge(
    """The method to use when ordering `Genre`."""
    orderBy: [GenresOrderBy!] = [PRIMARY_KEY_ASC]
  ): GenresEdge
}

"""All input for the `deleteGenreByNodeId` mutation."""
input DeleteGenreByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Genre` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteGenre` mutation."""
input DeleteGenreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""All input for the `deleteGenreByGenre` mutation."""
input DeleteGenreByGenreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  genre: String!
}

"""The output of our delete `Image` mutation."""
type DeleteImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Image` that was deleted by this mutation."""
  image: Image
  deletedImageNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Image`. May be used by Relay 1."""
  imageEdge(
    """The method to use when ordering `Image`."""
    orderBy: [ImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ImagesEdge
}

"""All input for the `deleteImageByNodeId` mutation."""
input DeleteImageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Image` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteImage` mutation."""
input DeleteImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Licensor` mutation."""
type DeleteLicensorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Licensor` that was deleted by this mutation."""
  licensor: Licensor
  deletedLicensorNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Licensor`. May be used by Relay 1."""
  licensorEdge(
    """The method to use when ordering `Licensor`."""
    orderBy: [LicensorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LicensorsEdge
}

"""All input for the `deleteLicensorByNodeId` mutation."""
input DeleteLicensorByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Licensor` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLicensor` mutation."""
input DeleteLicensorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""All input for the `deleteLicensorByLicensor` mutation."""
input DeleteLicensorByLicensorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  licensor: String!
}

"""The output of our delete `PersonImage` mutation."""
type DeletePersonImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PersonImage` that was deleted by this mutation."""
  personImage: PersonImage
  deletedPersonImageNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Person` that is related to this `PersonImage`."""
  person: Person

  """Reads a single `Image` that is related to this `PersonImage`."""
  image: Image

  """An edge for our `PersonImage`. May be used by Relay 1."""
  personImageEdge(
    """The method to use when ordering `PersonImage`."""
    orderBy: [PersonImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PersonImagesEdge
}

"""All input for the `deletePersonImageByNodeId` mutation."""
input DeletePersonImageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PersonImage` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePersonImage` mutation."""
input DeletePersonImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId: UUID!
  imageId: UUID!
}

"""The output of our delete `Person` mutation."""
type DeletePersonPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Person` that was deleted by this mutation."""
  person: Person
  deletedPersonNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Image` that is related to this `Person`."""
  personImage: Image

  """An edge for our `Person`. May be used by Relay 1."""
  personEdge(
    """The method to use when ordering `Person`."""
    orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]
  ): PeopleEdge
}

"""All input for the `deletePersonByNodeId` mutation."""
input DeletePersonByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Person` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePerson` mutation."""
input DeletePersonInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""All input for the `deletePersonByMalId` mutation."""
input DeletePersonByMalIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  malId: String!
}

"""The output of our delete `Producer` mutation."""
type DeleteProducerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Producer` that was deleted by this mutation."""
  producer: Producer
  deletedProducerNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Producer`. May be used by Relay 1."""
  producerEdge(
    """The method to use when ordering `Producer`."""
    orderBy: [ProducersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProducersEdge
}

"""All input for the `deleteProducerByNodeId` mutation."""
input DeleteProducerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Producer` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteProducer` mutation."""
input DeleteProducerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""All input for the `deleteProducerByProducer` mutation."""
input DeleteProducerByProducerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  producer: String!
}

"""The output of our delete `StaffRole` mutation."""
type DeleteStaffRolePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StaffRole` that was deleted by this mutation."""
  staffRole: StaffRole
  deletedStaffRoleNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `StaffRole`. May be used by Relay 1."""
  staffRoleEdge(
    """The method to use when ordering `StaffRole`."""
    orderBy: [StaffRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StaffRolesEdge
}

"""All input for the `deleteStaffRoleByNodeId` mutation."""
input DeleteStaffRoleByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `StaffRole` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteStaffRole` mutation."""
input DeleteStaffRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""All input for the `deleteStaffRoleByRole` mutation."""
input DeleteStaffRoleByRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  role: String!
}

"""The output of our delete `Studio` mutation."""
type DeleteStudioPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Studio` that was deleted by this mutation."""
  studio: Studio
  deletedStudioNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Studio`. May be used by Relay 1."""
  studioEdge(
    """The method to use when ordering `Studio`."""
    orderBy: [StudiosOrderBy!] = [PRIMARY_KEY_ASC]
  ): StudiosEdge
}

"""All input for the `deleteStudioByNodeId` mutation."""
input DeleteStudioByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Studio` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteStudio` mutation."""
input DeleteStudioInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""All input for the `deleteStudioByStudio` mutation."""
input DeleteStudioByStudioInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  studio: String!
}

"""The output of our delete `UserAnime` mutation."""
type DeleteUserAnimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserAnime` that was deleted by this mutation."""
  userAnime: UserAnime
  deletedUserAnimeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `UserAnime`."""
  anime: Anime

  """Reads a single `User` that is related to this `UserAnime`."""
  user: User

  """An edge for our `UserAnime`. May be used by Relay 1."""
  userAnimeEdge(
    """The method to use when ordering `UserAnime`."""
    orderBy: [UserAnimeOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserAnimeEdge
}

"""All input for the `deleteUserAnimeByNodeId` mutation."""
input DeleteUserAnimeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserAnime` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUserAnime` mutation."""
input DeleteUserAnimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  animeId: UUID!
  userId: String!
}

"""The output of our delete `UserAnimeList` mutation."""
type DeleteUserAnimeListPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserAnimeList` that was deleted by this mutation."""
  userAnimeList: UserAnimeList
  deletedUserAnimeListNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `AnimeList` that is related to this `UserAnimeList`."""
  animeList: AnimeList

  """Reads a single `Anime` that is related to this `UserAnimeList`."""
  anime: Anime

  """An edge for our `UserAnimeList`. May be used by Relay 1."""
  userAnimeListEdge(
    """The method to use when ordering `UserAnimeList`."""
    orderBy: [UserAnimeListsOrderBy!] = [NATURAL]
  ): UserAnimeListsEdge
}

"""
All input for the `deleteUserAnimeListByAnimeListIdAndAnimeId` mutation.
"""
input DeleteUserAnimeListByAnimeListIdAndAnimeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  animeListId: UUID!
  animeId: UUID!
}

"""The output of our delete `UserNotification` mutation."""
type DeleteUserNotificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserNotification` that was deleted by this mutation."""
  userNotification: UserNotification
  deletedUserNotificationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserNotification`."""
  user: User

  """An edge for our `UserNotification`. May be used by Relay 1."""
  userNotificationEdge(
    """The method to use when ordering `UserNotification`."""
    orderBy: [UserNotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserNotificationsEdge
}

"""All input for the `deleteUserNotificationByNodeId` mutation."""
input DeleteUserNotificationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserNotification` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUserNotification` mutation."""
input DeleteUserNotificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `UserWatchStatus` mutation."""
type DeleteUserWatchStatusPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserWatchStatus` that was deleted by this mutation."""
  userWatchStatus: UserWatchStatus
  deletedUserWatchStatusNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserWatchStatus`."""
  user: User

  """Reads a single `Anime` that is related to this `UserWatchStatus`."""
  anime: Anime

  """An edge for our `UserWatchStatus`. May be used by Relay 1."""
  userWatchStatusEdge(
    """The method to use when ordering `UserWatchStatus`."""
    orderBy: [UserWatchStatusesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserWatchStatusesEdge
}

"""All input for the `deleteUserWatchStatusByNodeId` mutation."""
input DeleteUserWatchStatusByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserWatchStatus` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUserWatchStatus` mutation."""
input DeleteUserWatchStatusInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  userId: String!
  animeId: UUID!
}

"""The output of our delete `User` mutation."""
type DeleteUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was deleted by this mutation."""
  user: User
  deletedUserNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `deleteUserByNodeId` mutation."""
input DeleteUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUser` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our `addAnimeToList` mutation."""
type AddAnimeToListPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  animeList: AnimeList

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `AnimeList`."""
  user: User

  """An edge for our `AnimeList`. May be used by Relay 1."""
  animeListEdge(
    """The method to use when ordering `AnimeList`."""
    orderBy: [AnimeListsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeListsEdge
}

"""All input for the `addAnimeToList` mutation."""
input AddAnimeToListInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  userId: String
  animeId: UUID
  title: String
  privacy: AnimeListPrivacy
  watchStatus: String
}

"""The output of our `changeUsername` mutation."""
type ChangeUsernamePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  string: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `changeUsername` mutation."""
input ChangeUsernameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  usernameInput: String!
}

"""The output of our `createNewListAddAnime` mutation."""
type CreateNewListAddAnimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  animeList: AnimeList

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `AnimeList`."""
  user: User

  """An edge for our `AnimeList`. May be used by Relay 1."""
  animeListEdge(
    """The method to use when ordering `AnimeList`."""
    orderBy: [AnimeListsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeListsEdge
}

"""All input for the `createNewListAddAnime` mutation."""
input CreateNewListAddAnimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  animeidinput: UUID!
}

"""The output of our `insertAnimeToUserList` mutation."""
type InsertAnimeToUserListPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  userAnimeList: UserAnimeList

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `AnimeList` that is related to this `UserAnimeList`."""
  animeList: AnimeList

  """Reads a single `Anime` that is related to this `UserAnimeList`."""
  anime: Anime

  """An edge for our `UserAnimeList`. May be used by Relay 1."""
  userAnimeListEdge(
    """The method to use when ordering `UserAnimeList`."""
    orderBy: [UserAnimeListsOrderBy!] = [NATURAL]
  ): UserAnimeListsEdge
}

"""All input for the `insertAnimeToUserList` mutation."""
input InsertAnimeToUserListInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  inputAnimeId: UUID
  inputAnimeListId: UUID
  inputAnimeIndex: String
  inputWatchStatus: String
}

"""The output of our `insertOrUpdateAnimeUserScore` mutation."""
type InsertOrUpdateAnimeUserScorePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  animeUserScore: AnimeUserScore

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeUserScore`."""
  anime: Anime

  """Reads a single `User` that is related to this `AnimeUserScore`."""
  user: User

  """An edge for our `AnimeUserScore`. May be used by Relay 1."""
  animeUserScoreEdge(
    """The method to use when ordering `AnimeUserScore`."""
    orderBy: [AnimeUserScoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeUserScoresEdge
}

"""All input for the `insertOrUpdateAnimeUserScore` mutation."""
input InsertOrUpdateAnimeUserScoreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  inputAnimeId: UUID!
  inputUserScore: Int!
}

"""The output of our `registerUser` mutation."""
type RegisterUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `registerUser` mutation."""
input RegisterUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  userId: String!
  username: String!
  email: String!
}

"""The output of our upsert `AlternateAnimeName` mutation."""
type UpsertAlternateAnimeNamePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AlternateAnimeName` that was upserted by this mutation."""
  alternateAnimeName: AlternateAnimeName

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AlternateAnimeName`."""
  anime: Anime

  """An edge for our `AlternateAnimeName`. May be used by Relay 1."""
  alternateAnimeNameEdge(
    """The method to use when ordering `AlternateAnimeName`."""
    orderBy: [AlternateAnimeNamesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AlternateAnimeNamesEdge
}

"""Where conditions for the upsert `AlternateAnimeName` mutation."""
input UpsertAlternateAnimeNameWhere {
  id: UUID
}

"""All input for the upsert `AlternateAnimeName` mutation."""
input UpsertAlternateAnimeNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AlternateAnimeName` to be upserted by this mutation."""
  alternateAnimeName: AlternateAnimeNameInput!
}

"""The output of our upsert `AnimeCharacter` mutation."""
type UpsertAnimeCharacterPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeCharacter` that was upserted by this mutation."""
  animeCharacter: AnimeCharacter

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeCharacter`."""
  anime: Anime

  """Reads a single `Character` that is related to this `AnimeCharacter`."""
  character: Character

  """Reads a single `Person` that is related to this `AnimeCharacter`."""
  person: Person

  """
  Reads a single `CharacterRole` that is related to this `AnimeCharacter`.
  """
  characterRole: CharacterRole

  """An edge for our `AnimeCharacter`. May be used by Relay 1."""
  animeCharacterEdge(
    """The method to use when ordering `AnimeCharacter`."""
    orderBy: [AnimeCharactersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeCharactersEdge
}

"""Where conditions for the upsert `AnimeCharacter` mutation."""
input UpsertAnimeCharacterWhere {
  animeId: UUID
  characterId: UUID
  personId: UUID
  characterRoleId: UUID
  language: LanguageType
}

"""All input for the upsert `AnimeCharacter` mutation."""
input UpsertAnimeCharacterInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeCharacter` to be upserted by this mutation."""
  animeCharacter: AnimeCharacterInput!
}

"""The output of our upsert `AnimeGenre` mutation."""
type UpsertAnimeGenrePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeGenre` that was upserted by this mutation."""
  animeGenre: AnimeGenre

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeGenre`."""
  anime: Anime

  """Reads a single `Genre` that is related to this `AnimeGenre`."""
  genre: Genre

  """An edge for our `AnimeGenre`. May be used by Relay 1."""
  animeGenreEdge(
    """The method to use when ordering `AnimeGenre`."""
    orderBy: [AnimeGenresOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeGenresEdge
}

"""Where conditions for the upsert `AnimeGenre` mutation."""
input UpsertAnimeGenreWhere {
  animeId: UUID
  genreId: UUID
}

"""All input for the upsert `AnimeGenre` mutation."""
input UpsertAnimeGenreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeGenre` to be upserted by this mutation."""
  animeGenre: AnimeGenreInput!
}

"""The output of our upsert `AnimeImage` mutation."""
type UpsertAnimeImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeImage` that was upserted by this mutation."""
  animeImage: AnimeImage

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeImage`."""
  anime: Anime

  """Reads a single `Image` that is related to this `AnimeImage`."""
  image: Image

  """An edge for our `AnimeImage`. May be used by Relay 1."""
  animeImageEdge(
    """The method to use when ordering `AnimeImage`."""
    orderBy: [AnimeImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeImagesEdge
}

"""Where conditions for the upsert `AnimeImage` mutation."""
input UpsertAnimeImageWhere {
  animeId: UUID
  imageId: UUID
}

"""All input for the upsert `AnimeImage` mutation."""
input UpsertAnimeImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeImage` to be upserted by this mutation."""
  animeImage: AnimeImageInput!
}

"""The output of our upsert `AnimeLicensor` mutation."""
type UpsertAnimeLicensorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeLicensor` that was upserted by this mutation."""
  animeLicensor: AnimeLicensor

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeLicensor`."""
  anime: Anime

  """Reads a single `Licensor` that is related to this `AnimeLicensor`."""
  licensor: Licensor

  """An edge for our `AnimeLicensor`. May be used by Relay 1."""
  animeLicensorEdge(
    """The method to use when ordering `AnimeLicensor`."""
    orderBy: [AnimeLicensorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeLicensorsEdge
}

"""Where conditions for the upsert `AnimeLicensor` mutation."""
input UpsertAnimeLicensorWhere {
  animeId: UUID
  licensorId: UUID
}

"""All input for the upsert `AnimeLicensor` mutation."""
input UpsertAnimeLicensorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeLicensor` to be upserted by this mutation."""
  animeLicensor: AnimeLicensorInput!
}

"""The output of our upsert `AnimeList` mutation."""
type UpsertAnimeListPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeList` that was upserted by this mutation."""
  animeList: AnimeList

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `AnimeList`."""
  user: User

  """An edge for our `AnimeList`. May be used by Relay 1."""
  animeListEdge(
    """The method to use when ordering `AnimeList`."""
    orderBy: [AnimeListsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeListsEdge
}

"""Where conditions for the upsert `AnimeList` mutation."""
input UpsertAnimeListWhere {
  id: UUID
}

"""All input for the upsert `AnimeList` mutation."""
input UpsertAnimeListInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeList` to be upserted by this mutation."""
  animeList: AnimeListInput!
}

"""The output of our upsert `AnimeProducer` mutation."""
type UpsertAnimeProducerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeProducer` that was upserted by this mutation."""
  animeProducer: AnimeProducer

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeProducer`."""
  anime: Anime

  """Reads a single `Producer` that is related to this `AnimeProducer`."""
  producer: Producer

  """An edge for our `AnimeProducer`. May be used by Relay 1."""
  animeProducerEdge(
    """The method to use when ordering `AnimeProducer`."""
    orderBy: [AnimeProducersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeProducersEdge
}

"""Where conditions for the upsert `AnimeProducer` mutation."""
input UpsertAnimeProducerWhere {
  animeId: UUID
  producerId: UUID
}

"""All input for the upsert `AnimeProducer` mutation."""
input UpsertAnimeProducerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeProducer` to be upserted by this mutation."""
  animeProducer: AnimeProducerInput!
}

"""The output of our upsert `AnimeStaff` mutation."""
type UpsertAnimeStaffPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeStaff` that was upserted by this mutation."""
  animeStaff: AnimeStaff

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeStaff`."""
  anime: Anime

  """Reads a single `Person` that is related to this `AnimeStaff`."""
  person: Person

  """Reads a single `StaffRole` that is related to this `AnimeStaff`."""
  staffRole: StaffRole

  """An edge for our `AnimeStaff`. May be used by Relay 1."""
  animeStaffEdge(
    """The method to use when ordering `AnimeStaff`."""
    orderBy: [AnimeStaffOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeStaffEdge
}

"""Where conditions for the upsert `AnimeStaff` mutation."""
input UpsertAnimeStaffWhere {
  animeId: UUID
  personId: UUID
  staffRoleId: UUID
}

"""All input for the upsert `AnimeStaff` mutation."""
input UpsertAnimeStaffInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeStaff` to be upserted by this mutation."""
  animeStaff: AnimeStaffInput!
}

"""The output of our upsert `AnimeStreamingOn` mutation."""
type UpsertAnimeStreamingOnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeStreamingOn` that was upserted by this mutation."""
  animeStreamingOn: AnimeStreamingOn

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeStreamingOn`."""
  anime: Anime

  """An edge for our `AnimeStreamingOn`. May be used by Relay 1."""
  animeStreamingOnEdge(
    """The method to use when ordering `AnimeStreamingOn`."""
    orderBy: [AnimeStreamingOnsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeStreamingOnsEdge
}

"""Where conditions for the upsert `AnimeStreamingOn` mutation."""
input UpsertAnimeStreamingOnWhere {
  animeId: UUID
  streamServiceId: StreamingServices
}

"""All input for the upsert `AnimeStreamingOn` mutation."""
input UpsertAnimeStreamingOnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeStreamingOn` to be upserted by this mutation."""
  animeStreamingOn: AnimeStreamingOnInput!
}

"""The output of our upsert `AnimeStudio` mutation."""
type UpsertAnimeStudioPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeStudio` that was upserted by this mutation."""
  animeStudio: AnimeStudio

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeStudio`."""
  anime: Anime

  """Reads a single `Studio` that is related to this `AnimeStudio`."""
  studio: Studio

  """An edge for our `AnimeStudio`. May be used by Relay 1."""
  animeStudioEdge(
    """The method to use when ordering `AnimeStudio`."""
    orderBy: [AnimeStudiosOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeStudiosEdge
}

"""Where conditions for the upsert `AnimeStudio` mutation."""
input UpsertAnimeStudioWhere {
  animeId: UUID
  studioId: UUID
}

"""All input for the upsert `AnimeStudio` mutation."""
input UpsertAnimeStudioInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeStudio` to be upserted by this mutation."""
  animeStudio: AnimeStudioInput!
}

"""The output of our upsert `AnimeUserScore` mutation."""
type UpsertAnimeUserScorePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AnimeUserScore` that was upserted by this mutation."""
  animeUserScore: AnimeUserScore

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `AnimeUserScore`."""
  anime: Anime

  """Reads a single `User` that is related to this `AnimeUserScore`."""
  user: User

  """An edge for our `AnimeUserScore`. May be used by Relay 1."""
  animeUserScoreEdge(
    """The method to use when ordering `AnimeUserScore`."""
    orderBy: [AnimeUserScoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeUserScoresEdge
}

"""Where conditions for the upsert `AnimeUserScore` mutation."""
input UpsertAnimeUserScoreWhere {
  animeId: UUID
  userId: String
}

"""All input for the upsert `AnimeUserScore` mutation."""
input UpsertAnimeUserScoreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AnimeUserScore` to be upserted by this mutation."""
  animeUserScore: AnimeUserScoreInput!
}

"""The output of our upsert `Anime` mutation."""
type UpsertAnimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Anime` that was upserted by this mutation."""
  anime: Anime

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Anime`. May be used by Relay 1."""
  animeEdge(
    """The method to use when ordering `Anime`."""
    orderBy: [AnimeOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnimeEdge
}

"""Where conditions for the upsert `Anime` mutation."""
input UpsertAnimeWhere {
  id: UUID
  malId: Int
}

"""All input for the upsert `Anime` mutation."""
input UpsertAnimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Anime` to be upserted by this mutation."""
  anime: AnimeInput!
}

"""The output of our upsert `CharacterImage` mutation."""
type UpsertCharacterImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CharacterImage` that was upserted by this mutation."""
  characterImage: CharacterImage

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Character` that is related to this `CharacterImage`."""
  character: Character

  """Reads a single `Image` that is related to this `CharacterImage`."""
  image: Image

  """An edge for our `CharacterImage`. May be used by Relay 1."""
  characterImageEdge(
    """The method to use when ordering `CharacterImage`."""
    orderBy: [CharacterImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CharacterImagesEdge
}

"""Where conditions for the upsert `CharacterImage` mutation."""
input UpsertCharacterImageWhere {
  characterId: UUID
  imageId: UUID
}

"""All input for the upsert `CharacterImage` mutation."""
input UpsertCharacterImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CharacterImage` to be upserted by this mutation."""
  characterImage: CharacterImageInput!
}

"""The output of our upsert `CharacterRole` mutation."""
type UpsertCharacterRolePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CharacterRole` that was upserted by this mutation."""
  characterRole: CharacterRole

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `CharacterRole`. May be used by Relay 1."""
  characterRoleEdge(
    """The method to use when ordering `CharacterRole`."""
    orderBy: [CharacterRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CharacterRolesEdge
}

"""Where conditions for the upsert `CharacterRole` mutation."""
input UpsertCharacterRoleWhere {
  id: UUID
  role: String
}

"""All input for the upsert `CharacterRole` mutation."""
input UpsertCharacterRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CharacterRole` to be upserted by this mutation."""
  characterRole: CharacterRoleInput!
}

"""The output of our upsert `Character` mutation."""
type UpsertCharacterPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Character` that was upserted by this mutation."""
  character: Character

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Image` that is related to this `Character`."""
  characterImage: Image

  """An edge for our `Character`. May be used by Relay 1."""
  characterEdge(
    """The method to use when ordering `Character`."""
    orderBy: [CharactersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CharactersEdge
}

"""Where conditions for the upsert `Character` mutation."""
input UpsertCharacterWhere {
  id: UUID
  malId: String
}

"""All input for the upsert `Character` mutation."""
input UpsertCharacterInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Character` to be upserted by this mutation."""
  character: CharacterInput!
}

"""The output of our upsert `Genre` mutation."""
type UpsertGenrePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Genre` that was upserted by this mutation."""
  genre: Genre

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Genre`. May be used by Relay 1."""
  genreEdge(
    """The method to use when ordering `Genre`."""
    orderBy: [GenresOrderBy!] = [PRIMARY_KEY_ASC]
  ): GenresEdge
}

"""Where conditions for the upsert `Genre` mutation."""
input UpsertGenreWhere {
  id: UUID
  genre: String
}

"""All input for the upsert `Genre` mutation."""
input UpsertGenreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Genre` to be upserted by this mutation."""
  genre: GenreInput!
}

"""The output of our upsert `Image` mutation."""
type UpsertImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Image` that was upserted by this mutation."""
  image: Image

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Image`. May be used by Relay 1."""
  imageEdge(
    """The method to use when ordering `Image`."""
    orderBy: [ImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ImagesEdge
}

"""Where conditions for the upsert `Image` mutation."""
input UpsertImageWhere {
  id: UUID
}

"""All input for the upsert `Image` mutation."""
input UpsertImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Image` to be upserted by this mutation."""
  image: ImageInput!
}

"""The output of our upsert `Licensor` mutation."""
type UpsertLicensorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Licensor` that was upserted by this mutation."""
  licensor: Licensor

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Licensor`. May be used by Relay 1."""
  licensorEdge(
    """The method to use when ordering `Licensor`."""
    orderBy: [LicensorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LicensorsEdge
}

"""Where conditions for the upsert `Licensor` mutation."""
input UpsertLicensorWhere {
  id: UUID
  licensor: String
}

"""All input for the upsert `Licensor` mutation."""
input UpsertLicensorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Licensor` to be upserted by this mutation."""
  licensor: LicensorInput!
}

"""The output of our upsert `PersonImage` mutation."""
type UpsertPersonImagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PersonImage` that was upserted by this mutation."""
  personImage: PersonImage

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Person` that is related to this `PersonImage`."""
  person: Person

  """Reads a single `Image` that is related to this `PersonImage`."""
  image: Image

  """An edge for our `PersonImage`. May be used by Relay 1."""
  personImageEdge(
    """The method to use when ordering `PersonImage`."""
    orderBy: [PersonImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PersonImagesEdge
}

"""Where conditions for the upsert `PersonImage` mutation."""
input UpsertPersonImageWhere {
  personId: UUID
  imageId: UUID
}

"""All input for the upsert `PersonImage` mutation."""
input UpsertPersonImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `PersonImage` to be upserted by this mutation."""
  personImage: PersonImageInput!
}

"""The output of our upsert `Person` mutation."""
type UpsertPersonPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Person` that was upserted by this mutation."""
  person: Person

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Image` that is related to this `Person`."""
  personImage: Image

  """An edge for our `Person`. May be used by Relay 1."""
  personEdge(
    """The method to use when ordering `Person`."""
    orderBy: [PeopleOrderBy!] = [PRIMARY_KEY_ASC]
  ): PeopleEdge
}

"""Where conditions for the upsert `Person` mutation."""
input UpsertPersonWhere {
  id: UUID
  malId: String
}

"""All input for the upsert `Person` mutation."""
input UpsertPersonInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Person` to be upserted by this mutation."""
  person: PersonInput!
}

"""The output of our upsert `Producer` mutation."""
type UpsertProducerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Producer` that was upserted by this mutation."""
  producer: Producer

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Producer`. May be used by Relay 1."""
  producerEdge(
    """The method to use when ordering `Producer`."""
    orderBy: [ProducersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProducersEdge
}

"""Where conditions for the upsert `Producer` mutation."""
input UpsertProducerWhere {
  id: UUID
  producer: String
}

"""All input for the upsert `Producer` mutation."""
input UpsertProducerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Producer` to be upserted by this mutation."""
  producer: ProducerInput!
}

"""The output of our upsert `StaffRole` mutation."""
type UpsertStaffRolePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StaffRole` that was upserted by this mutation."""
  staffRole: StaffRole

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `StaffRole`. May be used by Relay 1."""
  staffRoleEdge(
    """The method to use when ordering `StaffRole`."""
    orderBy: [StaffRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StaffRolesEdge
}

"""Where conditions for the upsert `StaffRole` mutation."""
input UpsertStaffRoleWhere {
  id: UUID
  role: String
}

"""All input for the upsert `StaffRole` mutation."""
input UpsertStaffRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `StaffRole` to be upserted by this mutation."""
  staffRole: StaffRoleInput!
}

"""The output of our upsert `Studio` mutation."""
type UpsertStudioPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Studio` that was upserted by this mutation."""
  studio: Studio

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Studio`. May be used by Relay 1."""
  studioEdge(
    """The method to use when ordering `Studio`."""
    orderBy: [StudiosOrderBy!] = [PRIMARY_KEY_ASC]
  ): StudiosEdge
}

"""Where conditions for the upsert `Studio` mutation."""
input UpsertStudioWhere {
  id: UUID
  studio: String
}

"""All input for the upsert `Studio` mutation."""
input UpsertStudioInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Studio` to be upserted by this mutation."""
  studio: StudioInput!
}

"""The output of our upsert `UserAnime` mutation."""
type UpsertUserAnimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserAnime` that was upserted by this mutation."""
  userAnime: UserAnime

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Anime` that is related to this `UserAnime`."""
  anime: Anime

  """Reads a single `User` that is related to this `UserAnime`."""
  user: User

  """An edge for our `UserAnime`. May be used by Relay 1."""
  userAnimeEdge(
    """The method to use when ordering `UserAnime`."""
    orderBy: [UserAnimeOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserAnimeEdge
}

"""Where conditions for the upsert `UserAnime` mutation."""
input UpsertUserAnimeWhere {
  animeId: UUID
  userId: String
}

"""All input for the upsert `UserAnime` mutation."""
input UpsertUserAnimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserAnime` to be upserted by this mutation."""
  userAnime: UserAnimeInput!
}

"""The output of our upsert `UserAnimeList` mutation."""
type UpsertUserAnimeListPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserAnimeList` that was upserted by this mutation."""
  userAnimeList: UserAnimeList

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `AnimeList` that is related to this `UserAnimeList`."""
  animeList: AnimeList

  """Reads a single `Anime` that is related to this `UserAnimeList`."""
  anime: Anime

  """An edge for our `UserAnimeList`. May be used by Relay 1."""
  userAnimeListEdge(
    """The method to use when ordering `UserAnimeList`."""
    orderBy: [UserAnimeListsOrderBy!] = [NATURAL]
  ): UserAnimeListsEdge
}

"""Where conditions for the upsert `UserAnimeList` mutation."""
input UpsertUserAnimeListWhere {
  animeListId: UUID
  animeId: UUID
}

"""All input for the upsert `UserAnimeList` mutation."""
input UpsertUserAnimeListInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserAnimeList` to be upserted by this mutation."""
  userAnimeList: UserAnimeListInput!
}

"""The output of our upsert `UserNotification` mutation."""
type UpsertUserNotificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserNotification` that was upserted by this mutation."""
  userNotification: UserNotification

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserNotification`."""
  user: User

  """An edge for our `UserNotification`. May be used by Relay 1."""
  userNotificationEdge(
    """The method to use when ordering `UserNotification`."""
    orderBy: [UserNotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserNotificationsEdge
}

"""Where conditions for the upsert `UserNotification` mutation."""
input UpsertUserNotificationWhere {
  id: UUID
}

"""All input for the upsert `UserNotification` mutation."""
input UpsertUserNotificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserNotification` to be upserted by this mutation."""
  userNotification: UserNotificationInput!
}

"""The output of our upsert `UserWatchStatus` mutation."""
type UpsertUserWatchStatusPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UserWatchStatus` that was upserted by this mutation."""
  userWatchStatus: UserWatchStatus

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserWatchStatus`."""
  user: User

  """Reads a single `Anime` that is related to this `UserWatchStatus`."""
  anime: Anime

  """An edge for our `UserWatchStatus`. May be used by Relay 1."""
  userWatchStatusEdge(
    """The method to use when ordering `UserWatchStatus`."""
    orderBy: [UserWatchStatusesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserWatchStatusesEdge
}

"""Where conditions for the upsert `UserWatchStatus` mutation."""
input UpsertUserWatchStatusWhere {
  userId: String
  animeId: UUID
}

"""All input for the upsert `UserWatchStatus` mutation."""
input UpsertUserWatchStatusInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserWatchStatus` to be upserted by this mutation."""
  userWatchStatus: UserWatchStatusInput!
}

"""The output of our upsert `User` mutation."""
type UpsertUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was upserted by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""Where conditions for the upsert `User` mutation."""
input UpsertUserWhere {
  id: String
}

"""All input for the upsert `User` mutation."""
input UpsertUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `User` to be upserted by this mutation."""
  user: UserInput!
}

"""
The root subscription type: contains realtime events you can subscribe to with the `subscription` operation.
"""
type Subscription {
  notificationEvent: NotificationEvent
}

type NotificationEvent {
  event: String
  notification: UserNotification
}
